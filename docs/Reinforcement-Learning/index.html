

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Reinforcement Learning Library: pyqlearning &#8212; pyqlearning  documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pyqlearning package" href="pyqlearning.html" />
    <link rel="prev" title="Welcome to pyqlearning’s documentation!" href="index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyqlearning.html" title="pyqlearning package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to pyqlearning’s documentation!"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyqlearning  documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to pyqlearning’s documentation!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyqlearning.html"
                        title="next chapter">pyqlearning package</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="reinforcement-learning-library-pyqlearning">
<span id="reinforcement-learning-library-pyqlearning"></span><h1>Reinforcement Learning Library: pyqlearning<a class="headerlink" href="#reinforcement-learning-library-pyqlearning" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">pyqlearning</span></code> is Python library to implement Reinforcement Learning and Deep Reinforcement Learning, especially for Q-Learning, Deep Q-Network, and Multi-agent Deep Q-Network which can be optimized by Annealing models such as Simulated Annealing, Adaptive Simulated Annealing, and Quantum Monte Carlo Method.</p>
<p>This library makes it possible to design the information search algorithm such as the Game AI, web crawlers, or Robotics. But this library provides components for designers, not for end-users of state-of-the-art black boxes. Briefly speaking the philosophy of this library, <em>give user hype-driven blackboxes and you feed him for a day; show him how to design algorithms and you feed him for a lifetime.</em> So algorithm is power.</p>
<div align="center">
    <table style="border: none;">
        <tr>
            <td width="45%" align="center">
            <p><a href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/search_maze_by_deep_q_network.ipynb" target="_blank"><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/DQN_single_agent_goal_compressed-loop.gif" /></a></p>
            <p>Deep Reinforcement Learning (Deep Q-Network: DQN) to solve Maze.</p>
            </td>
            <td width="45%" align="center">
            <p><a href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/search_maze_by_deep_q_network.ipynb" target="_blank"><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/DQN_multi_agent_demo_goal_enemy_2-compressed.gif" /></a></p>
            <p>Multi-agent Deep Reinforcement Learning to solve the pursuit-evasion game.</p>
            </td>
        </tr>
    </table>
</div><div class="section" id="installation">
<span id="installation"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Install using pip:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip install pyqlearning
</pre></div>
</div>
<div class="section" id="source-code">
<span id="source-code"></span><h3>Source code<a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h3>
<p>The source code is currently hosted on GitHub.</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/chimera0/accel-brain-code/tree/master/Reinforcement-Learning">accel-brain-code/Reinforcement-Learning</a></li>
</ul>
</div>
<div class="section" id="python-package-index-pypi">
<span id="python-package-index-pypi"></span><h3>Python package index(PyPI)<a class="headerlink" href="#python-package-index-pypi" title="Permalink to this headline">¶</a></h3>
<p>Installers for the latest released version are available at the Python package index.</p>
<ul class="simple">
<li><a class="reference external" href="https://pypi.python.org/pypi/pyqlearning/">pyqlearning : Python Package Index</a></li>
</ul>
</div>
<div class="section" id="dependencies">
<span id="dependencies"></span><h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/numpy/numpy">numpy</a>: v1.13.3 or higher.</li>
<li><a class="reference external" href="https://github.com/pandas-dev/pandas">pandas</a>: v0.22.0 or higher.</li>
</ul>
<div class="section" id="option">
<span id="option"></span><h4>Option<a class="headerlink" href="#option" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference external" href="https://github.com/accel-brain/accel-brain-code/tree/master/Accel-Brain-Base">accel-brain-base</a>: v1.0.0 or higher.<ul>
<li>Only if you want to implement the <em>Deep</em> Reinforcement Learning.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="documentation">
<span id="documentation"></span><h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>Full documentation is available on <a class="reference external" href="https://code.accel-brain.com/Reinforcement-Learning/">https://code.accel-brain.com/Reinforcement-Learning/</a> . This document contains information on functionally reusability, functional scalability and functional extensibility.</p>
</div>
<div class="section" id="description">
<span id="description"></span><h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pyqlearning</span></code> is Python library to implement Reinforcement Learning and Deep Reinforcement Learning, especially for Q-Learning, Deep Q-Network, and Multi-agent Deep Q-Network which can be optimized by Annealing models such as Simulated Annealing, Adaptive Simulated Annealing, and Quantum Monte Carlo Method.</p>
<p>This library provides components for designers, not for end-users of state-of-the-art black boxes. Reinforcement learning algorithms are highly variable because they must design single or multi-agent behavior depending on their problem setup. Designers of algorithms and architectures are required to design according to the situation at each occasion. Commonization and commoditization for end users who want easy-to-use tools is not easy. Nonetheless, commonality / variability analysis and object-oriented analysis are not impossible. I am convinced that a designer who can <em>practice</em> <em>abstraction</em> of concepts by <em>drawing a distinction</em> of concepts related to his/her <em>own concrete problem settings</em> makes it possible to distinguish commonality and variability of various Reinforcement Learning algorithms.</p>
<div class="section" id="the-commonality-variability-of-epsilon-greedy-q-leanring-and-boltzmann-q-learning">
<span id="the-commonality-variability-of-epsilon-greedy-q-leanring-and-boltzmann-q-learning"></span><h3>The commonality/variability of Epsilon Greedy Q-Leanring and Boltzmann Q-Learning<a class="headerlink" href="#the-commonality-variability-of-epsilon-greedy-q-leanring-and-boltzmann-q-learning" title="Permalink to this headline">¶</a></h3>
<p>According to the Reinforcement Learning problem settings, Q-Learning is a kind of <strong>Temporal Difference learning(TD Learning)</strong> that can be considered as hybrid of <strong>Monte Carlo</strong> method and <strong>Dynamic Programming</strong> method. As Monte Carlo method, TD Learning algorithm can learn by experience without model of environment. And this learning algorithm is functional extension of bootstrap method as Dynamic Programming Method.</p>
<p>In this library, Q-Learning can be distinguished into <strong>Epsilon Greedy Q-Leanring</strong> and <strong>Boltzmann Q-Learning</strong>. These algorithm is functionally equivalent but their structures should be conceptually distinguished.</p>
<p>Epsilon Greedy Q-Leanring algorithm is a typical off-policy algorithm. In this paradigm, <em>stochastic</em> searching and <em>deterministic</em> searching can coexist by hyperparameter <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/epsilon.gif" /> that is probability that agent searches greedy. Greedy searching is <em>deterministic</em> in the sense that policy of agent follows the selection that maximizes the Q-Value.</p>
<p>Boltzmann Q-Learning algorithm is based on Boltzmann action selection mechanism, where the probability
<img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/x_i.gif" /> of selecting the action <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i.gif" /> is given by</p>
<!-- $$x_i(t) = \frac{e^{\frac{Q_i(t)}{T}}}{\sum_{k}^{ } e^{\frac{Q_i(t)}{T}}} \ \  (i = 1, 2, ..., n)$$ -->
<div><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/boltzmann_action_selection.gif" /></div><p>where the temperature <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/t_gt_0.gif" /> controls exploration/exploitation tradeoff. For <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/t_to_0.gif" /> the agent always acts greedily and chooses the strategy corresponding to the maximum Q–value, so as to be pure <em>deterministic</em> exploitation, whereas for <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/t_to_infty.gif" /> the agent’s strategy is completely random, so as to be pure <em>stochastic</em> exploration.</p>
</div>
<div class="section" id="commonality-variability-of-q-learning-models">
<span id="commonality-variability-of-q-learning-models"></span><h3>Commonality/variability of Q-learning models<a class="headerlink" href="#commonality-variability-of-q-learning-models" title="Permalink to this headline">¶</a></h3>
<p>Considering many variable parts and functional extensions in the Q-learning paradigm from perspective of <em>commonality/variability analysis</em> in order to practice object-oriented design, this library provides abstract class that defines the skeleton of a Q-Learning algorithm in an operation, deferring some steps in concrete variant algorithms such as Epsilon Greedy Q-Leanring and Boltzmann Q-Learning to client subclasses. The abstract class in this library lets subclasses redefine certain steps of a Q-Learning algorithm without changing the algorithm’s structure.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/class_diagram_pyqleanring_QLearning.png" /></p>
<p>Typical concepts such as <code class="docutils literal notranslate"><span class="pre">State</span></code>, <code class="docutils literal notranslate"><span class="pre">Action</span></code>, <code class="docutils literal notranslate"><span class="pre">Reward</span></code>, and <code class="docutils literal notranslate"><span class="pre">Q-Value</span></code> in Q-learning models should be refered as viewpoints for distinguishing between <em>commonality</em> and <em>variability</em>. Among the functions related to these concepts, the class <code class="docutils literal notranslate"><span class="pre">QLearning</span></code> is responsible for more <em>common</em> attributes and behaviors. On the other hand, in relation to <em>your</em> concrete problem settings, more <em>variable</em> elements have to be implemented by subclasses such as <code class="docutils literal notranslate"><span class="pre">YourGreedyQLearning</span></code> or <code class="docutils literal notranslate"><span class="pre">YourBoltzmannQLearning</span></code>.</p>
<p>For more detailed specification of this template method, refer to API documentation: <a class="reference external" href="https://code.accel-brain.com/Reinforcement-Learning/pyqlearning.html#module-pyqlearning.q_learning">pyqlearning.q_learning module</a>. If you want to know the samples of implemented code, see <a class="reference external" href="https://github.com/chimera0/accel-brain-code/tree/master/Reinforcement-Learning/demo">demo/</a>.</p>
</div>
<div class="section" id="structural-extension-deep-reinforcement-learning">
<span id="structural-extension-deep-reinforcement-learning"></span><h3>Structural extension: Deep Reinforcement Learning<a class="headerlink" href="#structural-extension-deep-reinforcement-learning" title="Permalink to this headline">¶</a></h3>
<p>The Reinforcement learning theory presents several issues from a perspective of deep learning theory(Mnih, V., et al. 2013). Firstly, deep learning applications have required large amounts of hand-labelled training data. Reinforcement learning algorithms, on the other hand, must be able to learn from a scalar reward signal that is frequently sparse, noisy and delayed.</p>
<p>The difference between the two theories is not only the type of data but also the timing to be observed. The delay between taking actions and receiving rewards, which can be thousands of timesteps long, seems particularly daunting when compared to the direct association between inputs and targets found in supervised learning.</p>
<p>Another issue is that deep learning algorithms assume the data samples to be independent, while in reinforcement learning one typically encounters sequences of highly correlated states. Furthermore, in Reinforcement learning, the data distribution changes as the algorithm learns new behaviours, presenting aspects of <em>recursive learning</em>, which can be problematic for deep learning methods that assume a fixed underlying distribution.</p>
<div class="section" id="generalisation-or-a-function-approximation">
<span id="generalisation-or-a-function-approximation"></span><h4>Generalisation, or a function approximation<a class="headerlink" href="#generalisation-or-a-function-approximation" title="Permalink to this headline">¶</a></h4>
<p>This library considers problem setteing in which an agent interacts with an environment <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/mathcal_E.png" />, in a sequence of actions, observations and rewards. At each time-step the agent selects an action at from the set of possible actions, <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/A_1_K.png" />. The state/action-value function is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_s_a.png" />.</p>
<p>The goal of the agent is to interact with the <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/mathcal_E.png" /> by selecting actions in a way that maximises future rewards. We can make the standard assumption that future rewards are discounted by a factor of $\gamma$ per time-step, and define the future discounted return at time <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/t.png" /> as</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/r_t_sum_t_t_T_gamma.png" />,</p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Tt.png" /> is the time-step at which the agent will reach the goal. This library defines the optimal state/action-value function <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_ast_s_a.png" /> as the maximum expected return achievable by following any strategy, after seeing some state <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/s.png" /> and then taking some action <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/a.png" />,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_ast_s_a_max_pi_E.png" />,</p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/pi.png" /> is a policy mapping sequences to actions (or distributions over actions).</p>
<p>The optimal state/action-value function obeys an important identity known as the Bellman equation. This is based on the following <em>intuition</em>: if the optimal value <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_ast_s_d_a_d.png" /> of the sequence <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/s_d.png" /> at the next time-step was known for all possible actions <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/a_d.png" />, then the optimal strategy is to select the action <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/a_d.png" /> maximising the expected value of</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/r_gamma_Q_ast_s_d_a_d.png" />,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_ast_s_d_a_d_mathbb_E_s_d_sim_mathcal_E.png" />.</p>
<p>The basic idea behind many reinforcement learning algorithms is to estimate the state/action-value function, by using the Bellman equation as an iterative update,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_i_1_s_a_mathbb_E_r_gamma_max_a_d.png" />.</p>
<p>Such <em>value iteration algorithms</em> converge to the optimal state/action-value function, <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_i_rightarrow_Q_ast.png" /> as <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i_rightarrow_infty.png" />.</p>
<p>But increasing the complexity of states/actions is equivalent to increasing the number of combinations of states/actions. If the value function is continuous and granularities of states/actions are extremely fine, the combinatorial explosion will be encountered. In other words, this basic approach is totally impractical, because the state/action-value function is estimated separately for each sequence, without any <strong>generalisation</strong>. Instead, it is common to use a <strong>function approximator</strong> to estimate the state/action-value function,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/Q_s_a_theta_approx_Q_ast_s_a.png" /></p>
<p>So the Reduction of complexities is required.</p>
</div>
</div>
<div class="section" id="deep-q-network">
<span id="deep-q-network"></span><h3>Deep Q-Network<a class="headerlink" href="#deep-q-network" title="Permalink to this headline">¶</a></h3>
<p>In this problem setting, the function of nerual network or deep learning is a function approximation with weights <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/theta.png" /> as a Q-Network. A Q-Network can be trained by minimising a loss functions <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/L_i_theta_i.png" /> that changes at each iteration <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i.png" />,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/L_i_theta_i_mathbb_E_s_a_sim_rho_cdot.png" /></p>
<p>where</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/y_i_mathbb_E_s_d_sim_mathcal_E_r_gamma_max_a_d.png" /></p>
<p>is the target for iteration <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i.png" /> and <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/rho_cdot.png" /> is a so-called behaviour distribution. This is probability distribution over states and actions. The parameters from the previous iteration <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/theta_i_1.png" /> are held fixed when optimising the loss function <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/L_i_theta_i.png" />. Differentiating the loss function with respect to the weights we arrive at the following gradient,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/nabla_theta_i_L_i_theta_i_mathbb_E_s_a_sim_rho_cdot.png" /></p>
</div>
</div>
<div class="section" id="tutorial-maze-solving-and-the-pursuit-evasion-game-by-deep-q-network-jupyter-notebook">
<span id="tutorial-maze-solving-and-the-pursuit-evasion-game-by-deep-q-network-jupyter-notebook"></span><h2>Tutorial: Maze Solving and the pursuit-evasion game by Deep Q-Network (Jupyter notebook)<a class="headerlink" href="#tutorial-maze-solving-and-the-pursuit-evasion-game-by-deep-q-network-jupyter-notebook" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/accel-brain/accel-brain-code/blob/master/Reinforcement-Learning/demo/search_maze_by_deep_q_network.ipynb">demo/search_maze_by_deep_q_network.ipynb</a> is a Jupyter notebook which demonstrates a maze solving algorithm based on Deep Q-Network, rigidly coupled with Deep Convolutional Neural Networks(Deep CNNs). The function of the Deep Learning is <strong>generalisation</strong> and CNNs is-a <strong>function approximator</strong>. In this notebook, several functional equivalents such as CNN and LSTM can be compared from a functional point of view.</p>
<div align="center">
    <p><a href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/search_maze_by_deep_q_network.ipynb" target="_blank"><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/DQN_single_agent_goal_compressed-loop.gif" /></a></p>
    <p>Deep Reinforcement Learning to solve the Maze.</p>
</div><ul class="simple">
<li>Black squares represent a wall.</li>
<li>Light gray squares represent passages.</li>
<li>A dark gray square represents a start point.</li>
<li>A white squeare represents a goal point.</li>
</ul>
<div class="section" id="the-pursuit-evasion-game">
<span id="the-pursuit-evasion-game"></span><h3>The pursuit-evasion game<a class="headerlink" href="#the-pursuit-evasion-game" title="Permalink to this headline">¶</a></h3>
<p>Expanding the search problem of the maze makes it possible to describe the pursuit-evasion game that is a family of problems in mathematics and computer science in which one group attempts to track down members of another group in an environment.</p>
<p>This problem can be re-described as the multi-agent control problem, which involves decomposing the global system state into an image like representation with information encoded in separate channels. This reformulation allows us to use convolutional neural networks to efficiently extract important features from the image-like state.</p>
<p>Egorov, M. (2016) and Gupta, J. K. et al.(2017) proposed new algorithm which uses the image-like state representation of the multi-agent system as an input, and outputs the estimated Q-values for the agent in question. They described a number of implementation contributions that make training efficient and allow agents to learn directly from the behavior of other agents in the system.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/multi_agent_q_learning_and_channels_big.png" /></p>
<p><cite><a href="https://pdfs.semanticscholar.org/dd98/9d94613f439c05725bad958929357e365084.pdf" target="_blank">Egorov, M. (2016). Multi-agent deep reinforcement learning., p4.</a></cite></p><p>An important aspect of this data modeling is that by expressing each state of the multi-agent as channels, it is possible to enclose states of all the agents as <strong>a target of convolution operation all at once</strong>. By the affine transformation executed by the neural network, combinations of an enormous number of states of multi-agent can be computed in principle with an allowable range of memory.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/multi_agent_q_learning_and_cnn_model_big.png" /></p>
<p><cite><a href="https://pdfs.semanticscholar.org/dd98/9d94613f439c05725bad958929357e365084.pdf" target="_blank">Egorov, M. (2016). Multi-agent deep reinforcement learning., p4.</a></cite></p><p><a class="reference external" href="https://github.com/accel-brain/accel-brain-code/blob/master/Reinforcement-Learning/demo/multi_agent_maze_by_deep_q_network.ipynb">demo/multi_agent_maze_by_deep_q_network.ipynb</a> also prototypes Multi Agent Deep Q-Network to solve the pursuit-evasion game based on the image-like state representation of the multi-agent.</p>
<div align="center">
    <table style="border: none;">
        <tr>
            <td width="45%" align="center">
            <p><a href="https://github.com/accel-brain/accel-brain-code/blob/master/Reinforcement-Learning/demo/multi_agent_maze_by_deep_q_network.ipynb" target="_blank"><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/DQN_multi_agent_demo_crash_enemy_2-compressed.gif" /></a></p>
            <p>Multi-agent Deep Reinforcement Learning to solve the pursuit-evasion game. The player is caught by enemies.</p>
            </td>
            <td width="45%" align="center">
            <p><a href="https://github.com/accel-brain/accel-brain-code/blob/master/Reinforcement-Learning/demo/multi_agent_maze_by_deep_q_network.ipynb" target="_blank"><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/DQN_multi_agent_demo_goal_enemy_2-compressed.gif" /></a></p>
            <p>
            <p>Multi-agent Deep Reinforcement Learning to solve the pursuit-evasion game. The player reaches the goal.</p>
            </td>
        </tr>
    </table>
</div><ul class="simple">
<li>Black squares represent a wall.</li>
<li>Light gray squares represent passages.</li>
<li>A dark gray square represents a start point.</li>
<li>Moving dark gray squares represent enemies.</li>
<li>A white squeare represents a goal point.</li>
</ul>
</div>
</div>
<div class="section" id="tutorial-complexity-of-hyperparameters-or-how-can-be-hyperparameters-decided">
<span id="tutorial-complexity-of-hyperparameters-or-how-can-be-hyperparameters-decided"></span><h2>Tutorial: Complexity of Hyperparameters, or how can be hyperparameters decided?<a class="headerlink" href="#tutorial-complexity-of-hyperparameters-or-how-can-be-hyperparameters-decided" title="Permalink to this headline">¶</a></h2>
<p>There are many hyperparameters that we have to set before the actual searching and learning process begins. Each parameter should be decided in relation to Deep/Reinforcement Learning theory and it cause side effects in training model. Because of this complexity of hyperparameters, so-called the hyperparameter tuning must become a burden of Data scientists and R &amp; D engineers from the perspective of not only a theoretical point of view but also implementation level.</p>
<div class="section" id="combinatorial-optimization-problem-and-simulated-annealing">
<span id="combinatorial-optimization-problem-and-simulated-annealing"></span><h3>Combinatorial optimization problem and Simulated Annealing.<a class="headerlink" href="#combinatorial-optimization-problem-and-simulated-annealing" title="Permalink to this headline">¶</a></h3>
<p>This issue can be considered as <strong>Combinatorial optimization problem</strong> which is an optimization problem, where an optimal solution has to be identified from a finite set of solutions. The solutions are normally discrete or can be converted into discrete. This is an important topic studied in operations research such as software engineering, artificial intelligence(AI), and machine learning. For instance, travelling sales man problem is one of the popular combinatorial optimization problem.</p>
<p>In this problem setting, this library provides an Annealing Model to search optimal combination of hyperparameters. For instance, <strong>Simulated Annealing</strong> is a probabilistic single solution based search method inspired by the annealing process in metallurgy. Annealing is a physical process referred to as tempering certain alloys of metal, glass, or crystal by heating above its melting point, holding its temperature, and then cooling it very slowly until it solidifies into a perfect crystalline structure. The simulation of this process is known as simulated annealing.</p>
</div>
<div class="section" id="functional-comparison">
<span id="functional-comparison"></span><h3>Functional comparison.<a class="headerlink" href="#functional-comparison" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/annealing_hand_written_digits.ipynb">demo/annealing_hand_written_digits.ipynb</a> is a Jupyter notebook which demonstrates a very simple classification problem: Recognizing hand-written digits, in which the aim is to assign each input vector to one of a finite number of discrete categories, to learn observed data points from already labeled data how to predict the class of unlabeled data. In the usecase of hand-written digits dataset, the task is to predict, given an image, which digit it represents.</p>
<p>There are many structural extensions and functional equivalents of <strong>Simulated Annealing</strong>. For instance, <strong>Adaptive Simulated Annealing</strong>, also known as the very fast simulated reannealing, is a very efficient version of simulated annealing. And <strong>Quantum Monte Carlo</strong>, which is generally known a stochastic method to solve the Schrödinger equation, is one of the earliest types of solution in order to simulate the <strong>Quantum Annealing</strong> in classical computer. In summary, one of the function of this algorithm is to solve the ground state search problem which is known as logically equivalent to combinatorial optimization problem. Then this Jupyter notebook demonstrates functional comparison in the same problem setting.</p>
</div>
</div>
<div class="section" id="demonstration-epsilon-greedy-q-learning-and-simulated-annealing">
<span id="demonstration-epsilon-greedy-q-learning-and-simulated-annealing"></span><h2>Demonstration: Epsilon Greedy Q-Learning and Simulated Annealing.<a class="headerlink" href="#demonstration-epsilon-greedy-q-learning-and-simulated-annealing" title="Permalink to this headline">¶</a></h2>
<p>Import python modules.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqlearning.annealingmodel.costfunctionable.greedy_q_learning_cost</span> <span class="kn">import</span> <span class="n">GreedyQLearningCost</span>
<span class="kn">from</span> <span class="nn">pyqlearning.annealingmodel.simulated_annealing</span> <span class="kn">import</span> <span class="n">SimulatedAnnealing</span>
<span class="c1"># See demo/demo_maze_greedy_q_learning.py</span>
<span class="kn">from</span> <span class="nn">demo.demo_maze_greedy_q_learning</span> <span class="kn">import</span> <span class="n">MazeGreedyQLearning</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">GreedyQLearningCost</span></code> is implemented the interface <code class="docutils literal notranslate"><span class="pre">CostFunctionable</span></code> to be called by <code class="docutils literal notranslate"><span class="pre">AnnealingModel</span></code>. This cost function is defined by</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/q_cost.gif"></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/n_search.gif"> is the number of searching(learning) and L is a limit of <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/n_search.gif">.</p>
<p>Like Monte Carlo method, let us draw random samples from a normal (Gaussian) or unifrom distribution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Epsilon-Greedy rate in Epsilon-Greedy-Q-Learning.</span>
<span class="n">greedy_rate_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># Alpha value in Q-Learning.</span>
<span class="n">alpha_value_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># Gamma value in Q-Learning.</span>
<span class="n">gamma_value_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># Limit of the number of Learning(searching).</span>
<span class="n">limit_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">var_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">greedy_rate_arr</span><span class="p">,</span> <span class="n">alpha_value_arr</span><span class="p">,</span> <span class="n">gamma_value_arr</span><span class="p">,</span> <span class="n">limit_arr</span><span class="p">]</span>
</pre></div>
</div>
<p>Instantiate and initialize <code class="docutils literal notranslate"><span class="pre">MazeGreedyQLearning</span></code> which is-a <code class="docutils literal notranslate"><span class="pre">GreedyQLearning</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiation.</span>
<span class="n">greedy_q_learning</span> <span class="o">=</span> <span class="n">MazeGreedyQLearning</span><span class="p">()</span>
<span class="n">greedy_q_learning</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">hoge</span><span class="o">=</span><span class="n">fuga</span><span class="p">)</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">GreedyQLearningCost</span></code> which is implemented the interface <code class="docutils literal notranslate"><span class="pre">CostFunctionable</span></code> to be called by <code class="docutils literal notranslate"><span class="pre">AnnealingModel</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init_state_key</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Some&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>
<span class="n">cost_functionable</span> <span class="o">=</span> <span class="n">GreedyQLearningCost</span><span class="p">(</span>
    <span class="n">greedy_q_learning</span><span class="p">,</span> 
    <span class="n">init_state_key</span><span class="o">=</span><span class="n">init_state_key</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">SimulatedAnnealing</span></code> which is-a <code class="docutils literal notranslate"><span class="pre">AnnealingModel</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">annealing_model</span> <span class="o">=</span> <span class="n">SimulatedAnnealing</span><span class="p">(</span>
    <span class="c1"># is-a `CostFunctionable`.</span>
    <span class="n">cost_functionable</span><span class="o">=</span><span class="n">cost_functionable</span><span class="p">,</span>
    <span class="c1"># The number of annealing cycles.</span>
    <span class="n">cycles_num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="c1"># The number of trials of searching per a cycle.</span>
    <span class="n">trials_per_cycle</span><span class="o">=</span><span class="mi">3</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Fit the <code class="docutils literal notranslate"><span class="pre">var_arr</span></code> to <code class="docutils literal notranslate"><span class="pre">annealing_model</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">annealing_model</span><span class="o">.</span><span class="n">var_arr</span> <span class="o">=</span> <span class="n">var_arr</span>
</pre></div>
</div>
<p>Start annealing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">annealing_model</span><span class="o">.</span><span class="n">annealing</span><span class="p">()</span>
</pre></div>
</div>
<p>To extract result of searching, call the property <code class="docutils literal notranslate"><span class="pre">predicted_log_list</span></code> which is list of tuple: <code class="docutils literal notranslate"><span class="pre">(Cost,</span> <span class="pre">Delta</span> <span class="pre">energy,</span> <span class="pre">Mean</span> <span class="pre">of</span> <span class="pre">delta</span> <span class="pre">energy,</span> <span class="pre">probability</span> <span class="pre">in</span> <span class="pre">Boltzmann</span> <span class="pre">distribution,</span> <span class="pre">accept</span> <span class="pre">flag)</span></code>. And refer the property <code class="docutils literal notranslate"><span class="pre">x</span></code> which is <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> that has combination of hyperparameters. The optimal combination can be extracted as follow.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract list: [(Cost, Delta energy, Mean of delta energy, probability, accept)]</span>
<span class="n">predicted_log_arr</span> <span class="o">=</span> <span class="n">annealing_model</span><span class="o">.</span><span class="n">predicted_log_arr</span>

<span class="c1"># [greedy rate, Alpha value, Gamma value, Limit of the number of searching.]</span>
<span class="n">min_e_v_arr</span> <span class="o">=</span> <span class="n">annealing_model</span><span class="o">.</span><span class="n">var_arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">predicted_log_arr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])]</span>
</pre></div>
</div>
<div class="section" id="contingency-of-definitions">
<span id="contingency-of-definitions"></span><h3>Contingency of definitions<a class="headerlink" href="#contingency-of-definitions" title="Permalink to this headline">¶</a></h3>
<p>The above definition of cost function is possible option: not necessity but contingent from the point of view of modal logic. You should questions the necessity of definition and re-define, for designing the implementation of interface <code class="docutils literal notranslate"><span class="pre">CostFunctionable</span></code>, in relation to <em>your</em> problem settings.</p>
</div>
</div>
<div class="section" id="demonstration-epsilon-greedy-q-learning-and-adaptive-simulated-annealing">
<span id="demonstration-epsilon-greedy-q-learning-and-adaptive-simulated-annealing"></span><h2>Demonstration: Epsilon Greedy Q-Learning and Adaptive Simulated Annealing.<a class="headerlink" href="#demonstration-epsilon-greedy-q-learning-and-adaptive-simulated-annealing" title="Permalink to this headline">¶</a></h2>
<p>There are various Simulated Annealing such as Boltzmann Annealing, Adaptive Simulated Annealing(SAS), and Quantum Simulated Annealing. On the premise of Combinatorial optimization problem, these annealing methods can be considered as functionally equivalent. The <em>Commonality/Variability</em> in these methods are able to keep responsibility of objects all straight as the class diagram below indicates.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/class_diagram_annealing_model.png" /></p>
<div class="section" id="code-sample">
<span id="code-sample"></span><h3>Code sample.<a class="headerlink" href="#code-sample" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AdaptiveSimulatedAnnealing</span></code> is-a subclass of <code class="docutils literal notranslate"><span class="pre">SimulatedAnnealing</span></code>. The <em>variability</em> is aggregated in the method <code class="docutils literal notranslate"><span class="pre">AdaptiveSimulatedAnnealing.adaptive_set()</span></code> which must be called before executing <code class="docutils literal notranslate"><span class="pre">AdaptiveSimulatedAnnealing.annealing()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqlearning.annealingmodel.simulatedannealing.adaptive_simulated_annealing</span> <span class="kn">import</span> <span class="n">AdaptiveSimulatedAnnealing</span>

<span class="n">annealing_model</span> <span class="o">=</span> <span class="n">AdaptiveSimulatedAnnealing</span><span class="p">(</span>
    <span class="n">cost_functionable</span><span class="o">=</span><span class="n">cost_functionable</span><span class="p">,</span>
    <span class="n">cycles_num</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span>
    <span class="n">trials_per_cycle</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">accepted_sol_num</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">init_prob</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="n">final_prob</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">start_pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">move_range</span><span class="o">=</span><span class="mi">3</span>
<span class="p">)</span>

<span class="c1"># Variability part.</span>
<span class="n">annealing_model</span><span class="o">.</span><span class="n">adaptive_set</span><span class="p">(</span>
    <span class="c1"># How often will this model reanneals there per cycles.</span>
    <span class="n">reannealing_per</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="c1"># Thermostat.</span>
    <span class="n">thermostat</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
    <span class="c1"># The minimum temperature.</span>
    <span class="n">t_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="c1"># The default temperature.</span>
    <span class="n">t_default</span><span class="o">=</span><span class="mf">1.0</span>
<span class="p">)</span>
<span class="n">annealing_model</span><span class="o">.</span><span class="n">var_arr</span> <span class="o">=</span> <span class="n">params_arr</span>
<span class="n">annealing_model</span><span class="o">.</span><span class="n">annealing</span><span class="p">()</span>
</pre></div>
</div>
<p>To extract result of searching, call the property like the case of using <code class="docutils literal notranslate"><span class="pre">SimulatedAnnealing</span></code>. If you want to know how to visualize the searching process, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/annealing_hand_written_digits.ipynb">demo/annealing_hand_written_digits.ipynb</a>.</p>
</div>
</div>
<div class="section" id="demonstration-epsilon-greedy-q-learning-and-quantum-monte-carlo">
<span id="demonstration-epsilon-greedy-q-learning-and-quantum-monte-carlo"></span><h2>Demonstration: Epsilon Greedy Q-Learning and Quantum Monte Carlo.<a class="headerlink" href="#demonstration-epsilon-greedy-q-learning-and-quantum-monte-carlo" title="Permalink to this headline">¶</a></h2>
<p>Generally, Quantum Monte Carlo is a stochastic method to solve the Schrödinger equation. This algorithm is one of the earliest types of solution in order to simulate the Quantum Annealing in classical computer. In summary, one of the function of this algorithm is to solve the ground state search problem which is known as logically equivalent to combinatorial optimization problem.</p>
<p>According to theory of spin glasses, the ground state search problem can be described as minimization energy determined by the hamiltonian <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/h_0.png" /> as follow</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/hamiltonian_in_ising_model.png" /></p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/pauli_z_i.png" /> refers to the Pauli spin matrix below for the spin-half particle at lattice point <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i.gif" />. In spin glasses, random value is assigned to <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/j_i_j.png" />. The number of combinations is enormous. If this value is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/n.png" />, a trial frequency is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/2_n.png" />. This computation complexity makes it impossible to solve the ground state search problem. Then, in theory of spin glasses, the standard hamiltonian is re-described in expanded form.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/hamiltonian_in_t_ising_model.png" /></p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/pauli_x_i.png" /> also refers to the Pauli spin matrix and <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/gamma.png" /> is so-called annealing coefficient, which is hyperparameter that contains vely high value. Ising model to follow this Hamiltonian is known as the Transverse Ising model.</p>
<p>In relation to this system, thermal equilibrium amount of a physical quantity <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/q.png?1" /> is as follow.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/langle_q_rangle.png" /></p>
<p>If <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/h.png" /> is a diagonal matrix, then also <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/e_beta_h.png" /> is diagonal matrix. If diagonal element in <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/h.png" /> is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/e_i.png" />, Each diagonal element is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/e_beta_h_ij_e_i.png" />. However if <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/h.png" /> has off-diagonal elements, It is known that <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/e_beta_h_ij_e_i_neq.png" /> since for any of the exponent <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/i.gif" /> we must exponentiate the matrix as follow.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/e_matrix_infty.png" /></p>
<p>Therefore, a path integration based on Trotter-Suzuki decomposition has been introduced in Quantum Monte Carlo Method. This path integration makes it possible to obtain the partition function <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z.png" />.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z_in_t_ising_model.png" /></p>
<p>where if <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/m.png" /> is large enough, relational expression below is established.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/exp_left_frac_1_m_beta_h_right.png" /></td></tr></p>
<p>Then the partition function <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z.png" /> can be re-descibed as follow.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z_in_t_ising_model_re_described.png" /></p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/mid_sigma_k_rangle.png" /> is <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/l.png" /> topological products (product spaces). Because <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/h_0.png" /> is the diagonal matrix, <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/tilde_sigma_j_z_mid_sigma.png" />.</p>
<p>Therefore,</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/langle_sigma_k_mid.png" /></p>
<p>The partition function <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z.png" /> can be re-descibed as follow.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/z_in_t_ising_model_re_described_last.png" /></p>
<p>where <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/m.png" /> is the number of trotter.</p>
<p>This relational expression indicates that the quantum - mechanical Hamiltonian in <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/d.png" /> dimentional Tranverse Ising model is functional equivalence to classical Hamiltonian in <img src="https://storage.googleapis.com/accel-brain-code/Reinforcement-Learning/img/latex/d_1.png" /> dimentional Ising model, which means that the state of the quantum - mechanical system can be approximate by the state of classical system.</p>
<div class="section" id="code-sample">
<span id="id1"></span><h3>Code sample.<a class="headerlink" href="#code-sample" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqlearning.annealingmodel.quantum_monte_carlo</span> <span class="kn">import</span> <span class="n">QuantumMonteCarlo</span>
<span class="kn">from</span> <span class="nn">pyqlearning.annealingmodel.distancecomputable.cost_as_distance</span> <span class="kn">import</span> <span class="n">CostAsDistance</span>

<span class="c1"># User defined function which is-a `CostFuntionable`.</span>
<span class="n">cost_functionable</span> <span class="o">=</span> <span class="n">YourCostFunctions</span><span class="p">()</span>

<span class="c1"># Compute cost as distance for `QuantumMonteCarlo`.</span>
<span class="n">distance_computable</span> <span class="o">=</span> <span class="n">CostAsDistance</span><span class="p">(</span><span class="n">params_arr</span><span class="p">,</span> <span class="n">cost_functionable</span><span class="p">)</span>

<span class="c1"># Init.</span>
<span class="n">annealing_model</span> <span class="o">=</span> <span class="n">QuantumMonteCarlo</span><span class="p">(</span>
    <span class="n">distance_computable</span><span class="o">=</span><span class="n">distance_computable</span><span class="p">,</span>

    <span class="c1"># The number of annealing cycles.</span>
    <span class="n">cycles_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>

    <span class="c1"># Inverse temperature (Beta).</span>
    <span class="n">inverse_temperature_beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>

    <span class="c1"># Gamma. (so-called annealing coefficient.) </span>
    <span class="n">gammma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>

    <span class="c1"># Attenuation rate for simulated time.</span>
    <span class="n">fractional_reduction</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>

    <span class="c1"># The dimention of Trotter.</span>
    <span class="n">trotter_dimention</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>

    <span class="c1"># The number of Monte Carlo steps.</span>
    <span class="n">mc_step</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>

    <span class="c1"># The number of parameters which can be optimized.</span>
    <span class="n">point_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>

    <span class="c1"># Default `np.ndarray` of 2-D spin glass in Ising model.</span>
    <span class="n">spin_arr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>

    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the ΔE is not improving by at least `tolerance_diff_e`</span>
    <span class="c1"># for two consecutive iterations, annealing will stops.</span>
    <span class="n">tolerance_diff_e</span><span class="o">=</span><span class="mf">0.01</span>
<span class="p">)</span>

<span class="c1"># Execute annealing.</span>
<span class="n">annealing_model</span><span class="o">.</span><span class="n">annealing</span><span class="p">()</span>
</pre></div>
</div>
<p>To extract result of searching, call the property like the case of using <code class="docutils literal notranslate"><span class="pre">SimulatedAnnealing</span></code>. If you want to know how to visualize the searching process, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Reinforcement-Learning/demo/annealing_hand_written_digits.ipynb">demo/annealing_hand_written_digits.ipynb</a>.</p>
</div>
</div>
<div class="section" id="references">
<span id="references"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<div class="section" id="q-learning-models">
<span id="q-learning-models"></span><h3>Q-Learning models.<a class="headerlink" href="#q-learning-models" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Agrawal, S., &amp; Goyal, N. (2011). Analysis of Thompson sampling for the multi-armed bandit problem. arXiv preprint arXiv:1111.1797.</li>
<li>Bubeck, S., &amp; Cesa-Bianchi, N. (2012). Regret analysis of stochastic and nonstochastic multi-armed bandit problems. arXiv preprint arXiv:1204.5721.</li>
<li>Chapelle, O., &amp; Li, L. (2011). An empirical evaluation of thompson sampling. In Advances in neural information processing systems (pp. 2249-2257).</li>
<li>Du, K. L., &amp; Swamy, M. N. S. (2016). Search and optimization by metaheuristics (p. 434). New York City: Springer.</li>
<li>Kaufmann, E., Cappe, O., &amp; Garivier, A. (2012). On Bayesian upper confidence bounds for bandit problems. In International Conference on Artificial Intelligence and Statistics (pp. 592-600).</li>
<li>Mnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D., &amp; Riedmiller, M. (2013). Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602.</li>
<li>Richard Sutton and Andrew Barto (1998). Reinforcement Learning. MIT Press.</li>
<li>Watkins, C. J. C. H. (1989). Learning from delayed rewards (Doctoral dissertation, University of Cambridge).</li>
<li>Watkins, C. J., &amp; Dayan, P. (1992). Q-learning. Machine learning, 8(3-4), 279-292.</li>
<li>White, J. (2012). Bandit algorithms for website optimization. ” O’Reilly Media, Inc.”.</li>
</ul>
</div>
<div class="section" id="deep-q-network-models">
<span id="deep-q-network-models"></span><h3>Deep Q-Network models.<a class="headerlink" href="#deep-q-network-models" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Cho, K., Van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., &amp; Bengio, Y. (2014). Learning phrase representations using RNN encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078.</li>
<li><a href="https://pdfs.semanticscholar.org/dd98/9d94613f439c05725bad958929357e365084.pdf" target="_blank">Egorov, M. (2016). Multi-agent deep reinforcement learning.</a></li>
<li>Gupta, J. K., Egorov, M., &amp; Kochenderfer, M. (2017, May). Cooperative multi-agent control using deep reinforcement learning. In International Conference on Autonomous Agents and Multiagent Systems (pp. 66-83). Springer, Cham.</li>
<li>Malhotra, P., Ramakrishnan, A., Anand, G., Vig, L., Agarwal, P., &amp; Shroff, G. (2016). LSTM-based encoder-decoder for multi-sensor anomaly detection. arXiv preprint arXiv:1607.00148.</li>
<li>Mnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D., &amp; Riedmiller, M. (2013). Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602.</li>
<li>Sainath, T. N., Vinyals, O., Senior, A., &amp; Sak, H. (2015, April). Convolutional, long short-term memory, fully connected deep neural networks. In Acoustics, Speech and Signal Processing (ICASSP), 2015 IEEE International Conference on (pp. 4580-4584). IEEE.</li>
<li>Xingjian, S. H. I., Chen, Z., Wang, H., Yeung, D. Y., Wong, W. K., &amp; Woo, W. C. (2015). Convolutional LSTM network: A machine learning approach for precipitation nowcasting. In Advances in neural information processing systems (pp. 802-810).</li>
<li>Zaremba, W., Sutskever, I., &amp; Vinyals, O. (2014). Recurrent neural network regularization. arXiv preprint arXiv:1409.2329.</li>
</ul>
</div>
<div class="section" id="annealing-models">
<span id="annealing-models"></span><h3>Annealing models.<a class="headerlink" href="#annealing-models" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Bektas, T. (2006). The multiple traveling salesman problem: an overview of formulations and solution procedures. Omega, 34(3), 209-219.</li>
<li>Bertsimas, D., &amp; Tsitsiklis, J. (1993). Simulated annealing. Statistical science, 8(1), 10-15.</li>
<li>Das, A., &amp; Chakrabarti, B. K. (Eds.). (2005). Quantum annealing and related optimization methods (Vol. 679). Springer Science &amp; Business Media.</li>
<li>Du, K. L., &amp; Swamy, M. N. S. (2016). Search and optimization by metaheuristics. New York City: Springer.</li>
<li>Edwards, S. F., &amp; Anderson, P. W. (1975). Theory of spin glasses. Journal of Physics F: Metal Physics, 5(5), 965.</li>
<li>Facchi, P., &amp; Pascazio, S. (2008). Quantum Zeno dynamics: mathematical and physical aspects. Journal of Physics A: Mathematical and Theoretical, 41(49), 493001.</li>
<li>Heim, B., Rønnow, T. F., Isakov, S. V., &amp; Troyer, M. (2015). Quantum versus classical annealing of Ising spin glasses. Science, 348(6231), 215-217.</li>
<li>Heisenberg, W. (1925) Über quantentheoretische Umdeutung kinematischer und mechanischer Beziehungen. Z. Phys. 33, pp.879—893.</li>
<li>Heisenberg, W. (1927). Über den anschaulichen Inhalt der quantentheoretischen Kinematik und Mechanik. Zeitschrift fur Physik, 43, 172-198.</li>
<li>Heisenberg, W. (1984). The development of quantum mechanics. In Scientific Review Papers, Talks, and Books -Wissenschaftliche Übersichtsartikel, Vorträge und Bücher (pp. 226-237). Springer Berlin Heidelberg.
Hilgevoord, Jan and Uffink, Jos, “The Uncertainty Principle”, The Stanford Encyclopedia of Philosophy (Winter 2016 Edition), Edward N. Zalta (ed.), URL = ＜https://plato.stanford.edu/archives/win2016/entries/qt-uncertainty/＞.</li>
<li>Jarzynski, C. (1997). Nonequilibrium equality for free energy differences. Physical Review Letters, 78(14), 2690.</li>
<li>Messiah, A. (1966). Quantum mechanics. 2 (1966). North-Holland Publishing Company.</li>
<li>Mezard, M., &amp; Montanari, A. (2009). Information, physics, and computation. Oxford University Press.</li>
<li>Nallusamy, R., Duraiswamy, K., Dhanalaksmi, R., &amp; Parthiban, P. (2009). Optimization of non-linear multiple traveling salesman problem using k-means clustering, shrink wrap algorithm and meta-heuristics. International Journal of Nonlinear Science, 8(4), 480-487.</li>
<li>Schrödinger, E. (1926). Quantisierung als eigenwertproblem. Annalen der physik, 385(13), S.437-490.</li>
<li>Somma, R. D., Batista, C. D., &amp; Ortiz, G. (2007). Quantum approach to classical statistical mechanics. Physical review letters, 99(3), 030603.</li>
<li>鈴木正. (2008). 「組み合わせ最適化問題と量子アニーリング: 量子断熱発展の理論と性能評価」.,『物性研究』, 90(4): pp598-676. 参照箇所はpp619-624.</li>
<li>西森秀稔、大関真之(2018) 『量子アニーリングの基礎』須藤 彰三、岡 真 監修、共立出版、参照箇所はpp9-46.</li>
</ul>
</div>
<div class="section" id="more-detail-demos">
<span id="more-detail-demos"></span><h3>More detail demos<a class="headerlink" href="#more-detail-demos" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://media.accel-brain.com/_chimera-network-is-web-crawling-ai/">Webクローラ型人工知能：キメラ・ネットワークの仕様</a> (Japanese)<ul>
<li>20001 bots are running as 20001 web-crawlers and 20001 web-scrapers.</li>
</ul>
</li>
<li><a class="reference external" href="https://media.accel-brain.com/_chimera-network-is-robo-adviser/">ロボアドバイザー型人工知能：キメラ・ネットワークの仕様</a> (Japanese)<ul>
<li>The 20001 bots can also simulate the portfolio optimization of securities such as stocks and circulation currency such as cryptocurrencies.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="related-poc">
<span id="related-poc"></span><h3>Related PoC<a class="headerlink" href="#related-poc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/">量子力学、統計力学、熱力学における天才物理学者たちの神学的な形象について</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/historische-semantik-der-entropie-in-der-maxwell-boltzmann-verteilung/">熱力学の前史、マクスウェル＝ボルツマン分布におけるエントロピーの歴史的意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/statistische-mechanik-als-medium-und-ensemble-als-form/">メディアとしての統計力学と形式としてのアンサンブル、そのギブス的類推</a></li>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/maxwell-damon/">「マクスウェルの悪魔」、力学の基礎法則としての神</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/">Webクローラ型人工知能によるパラドックス探索暴露機能の社会進化論</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/sozialstruktur-des-world-wide-web-und-semantik-der-kunstlichen-intelligenz-des-web-crawlers/">World-Wide Webの社会構造とWebクローラ型人工知能の意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/semantik-der-semantik-und-beobachtung-der-beobachtung/">意味論の意味論、観察の観察</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/">深層強化学習のベイズ主義的な情報探索に駆動された自然言語処理の意味論</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/verstarkungslernalgorithmus-als-funktionale-erweiterung-des-banditenalgorithmus/">バンディットアルゴリズムの機能的拡張としての強化学習アルゴリズム</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/deep-learning-als-funktionsapproximator-fur-verstarktes-lernen/">深層強化学習の統計的機械学習、強化学習の関数近似器としての深層学習</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/">ハッカー倫理に準拠した人工知能のアーキテクチャ設計</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/sozialstruktur-des-architekturzentrum-designs-und-architektur-der-semantik/">アーキテクチャ中心設計の社会構造とアーキテクチャの意味論</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/data-modeling-von-korrespondenz-in-artificial-paradise/">「人工の理想」を背景とした「万物照応」のデータモデリング</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/data-modeling-von-korrespondenz-in-artificial-paradise/agent-in-reignforcement-lernen-als-funktionelle-aquivalente-von-spielern/">ギャンブラーの機能的等価物としての強化学習エージェント、投資における冷静沈着な精神の現在性</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="author">
<span id="author"></span><h2>Author<a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>accel-brain</li>
</ul>
</div>
<div class="section" id="author-uri">
<span id="author-uri"></span><h2>Author URI<a class="headerlink" href="#author-uri" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>https://accel-brain.co.jp/</li>
<li>https://accel-brain.com/</li>
</ul>
</div>
<div class="section" id="license">
<span id="license"></span><h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>GNU General Public License v2.0</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyqlearning.html" title="pyqlearning package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to pyqlearning’s documentation!"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyqlearning  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Accel Brain.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>