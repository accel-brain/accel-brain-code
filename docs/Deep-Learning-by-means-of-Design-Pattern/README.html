
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Deep Learning Library: pydbm &#8212; pydbm  documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydbm package" href="pydbm.html" />
    <link rel="prev" title="Welcome to pydbm’s documentation!" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pydbm.html" title="pydbm package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to pydbm’s documentation!"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pydbm  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="deep-learning-library-pydbm">
<span id="deep-learning-library-pydbm"></span><h1>Deep Learning Library: pydbm<a class="headerlink" href="#deep-learning-library-pydbm" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">pydbm</span></code> is Python library for building Restricted Boltzmann Machine(RBM), Deep Boltzmann Machine(DBM), Long Short-Term Memory Recurrent Temporal Restricted Boltzmann Machine(LSTM-RTRBM), and Shape Boltzmann Machine(Shape-BM). From the view points of functionally equivalents and structural expansions, this library also prototypes many variants such as Encoder/Decoder based on LSTM with an Attention mechanism, Convolutional Auto-Encoder, ConvLSTM, and Spatio-temporal Auto-Encoder.</p>
<p><code class="docutils literal notranslate"><span class="pre">pydbm</span></code> project is dormant. Instead, <a class="reference external" href="https://github.com/accel-brain/accel-brain-code/tree/master/Accel-Brain-Base">accel-brain-base</a> project is in progress.</p>
<div class="section" id="documentation">
<span id="documentation"></span><h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>Full documentation is available on <a class="reference external" href="https://code.accel-brain.com/Deep-Learning-by-means-of-Design-Pattern/">https://code.accel-brain.com/Deep-Learning-by-means-of-Design-Pattern/</a> . This document contains information on functionally reusability, functional scalability and functional extensibility.</p>
</div>
<div class="section" id="installation">
<span id="installation"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Install using pip:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip install <span class="s2">&quot;git+https://github.com/chimera0/accel-brain-code.git#egg=pydbm&amp;subdirectory=Deep-Learning-by-means-of-Design-Pattern&quot;</span>
</pre></div>
</div>
<p>Or, after cloning this repository, you can install this library with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git clone https://github.com/chimera0/accel-brain-code.git
<span class="nb">cd</span> Deep-Learning-by-means-of-Design-Pattern/
python setup.py bdist_wheel
pip install dist/pydbm-<span class="o">{</span>version<span class="o">}</span>-<span class="o">{</span>hoge<span class="o">}</span>.whl
</pre></div>
</div>
<div class="section" id="source-code">
<span id="source-code"></span><h3>Source code<a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h3>
<p>The source code is currently hosted on GitHub.</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/chimera0/accel-brain-code/tree/master/Deep-Learning-by-means-of-Design-Pattern">accel-brain-code/Deep-Learning-by-means-of-Design-Pattern</a></li>
</ul>
</div>
<div class="section" id="python-package-index-pypi">
<span id="python-package-index-pypi"></span><h3>Python package index(PyPI)<a class="headerlink" href="#python-package-index-pypi" title="Permalink to this headline">¶</a></h3>
<p>Installers for the latest released version are available at the Python package index.</p>
<ul class="simple">
<li><a class="reference external" href="https://pypi.python.org/pypi/pydbm">pydbm : Python Package Index</a></li>
</ul>
</div>
<div class="section" id="dependencies">
<span id="dependencies"></span><h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>numpy: v1.13.3 or higher.</li>
<li>cython: v0.27.1 or higher.</li>
</ul>
<div class="section" id="options">
<span id="options"></span><h4>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Pillow(PIL): v5.0.0 or higher.<ul>
<li>Only if you want to use <code class="docutils literal notranslate"><span class="pre">ImageGenerator</span></code>.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="description">
<span id="description"></span><h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>The function of <code class="docutils literal notranslate"><span class="pre">pydbm</span></code> is building and modeling <strong>Restricted Boltzmann Machine</strong>(RBM) and <strong>Deep Boltzmann Machine</strong>(DBM). The models are functionally equivalent to <strong>stacked auto-encoder</strong>. The basic function is the same as <strong>dimensions reduction</strong>(or <strong>pre-learning</strong>). And this library enables you to build many functional extensions from RBM and DBM such as Recurrent Temporal Restricted Boltzmann Machine(RTRBM), Recurrent Neural Network Restricted Boltzmann Machine(RNN-RBM), Long Short-Term Memory Recurrent Temporal Restricted Boltzmann Machine(LSTM-RTRBM), and Shape Boltzmann Machine(Shape-BM).</p>
<p>As more usecases, <strong>RTRBM</strong>, <strong>RNN-RBM</strong>, and <strong>LSTM-RTRBM</strong> can learn dependency structures in temporal patterns such as music, natural sentences, and n-gram. RTRBM is a probabilistic time-series model which can be viewed as a temporal stack of RBMs, where each RBM has a contextual hidden state that is received from the previous RBM and is used to modulate its hidden units bias. The RTRBM can be understood as a sequence of conditional RBMs whose parameters are the output of a deterministic RNN, with the constraint that the hidden units must describe the conditional distributions. This constraint can be lifted by combining a full RNN with distinct hidden units. In terms of this possibility, RNN-RBM and LSTM-RTRBM are structurally expanded model from RTRBM that allows more freedom to describe the temporal dependencies involved.</p>
<p>The usecases of <strong>Shape-BM</strong> are image segmentation, object detection, inpainting and graphics. Shape-BM is the model for the task of modeling binary shape images, in that samples from the model look realistic and it can generalize to generate samples that differ from training examples.</p>
<table border="0">
    <tr>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/horse099.jpg" />
        <p>Image in <a href="https://avaminzhang.wordpress.com/2012/12/07/%E3%80%90dataset%E3%80%91weizmann-horses/" target="_blank">the Weizmann horse dataset</a>.</p>
        </td>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/horse099_binary.png" />
            <p>Binarized image.</p>
        </td>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/reconstructed_horse099.gif" />
            <p>Reconstructed image by Shape-BM.</p>
        </td>
    </tr>
</table><div class="section" id="the-structure-of-rbm">
<span id="the-structure-of-rbm"></span><h3>The structure of RBM.<a class="headerlink" href="#the-structure-of-rbm" title="Permalink to this headline">¶</a></h3>
<p>According to graph theory, the structure of RBM corresponds to a complete bipartite graph which is a special kind of bipartite graph where every node in the visible layer is connected to every node in the hidden layer. Based on statistical mechanics and thermodynamics(Ackley, D. H., Hinton, G. E., &amp; Sejnowski, T. J. 1985), the state of this structure can be reflected by the energy function:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/energy_function_of_rbm.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/b.png" /> is a bias in visible layer, <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/c.png" /> is a bias in hidden layer, <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/v.png" /> is an activity or a state in visible layer, <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h.png" /> is an activity or a state in hidden layer, and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/w.png" /> is a weight matrix in visible and hidden layer. The activities can be calculated as the below product, since the link of activations of visible layer and hidden layer are conditionally independent.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/conditionally_independent.png" /></div>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/define_lambda.png" /></div></div>
<div class="section" id="the-learning-equations-of-rbm">
<span id="the-learning-equations-of-rbm"></span><h3>The learning equations of RBM.<a class="headerlink" href="#the-learning-equations-of-rbm" title="Permalink to this headline">¶</a></h3>
<p>Because of the rules of conditional independence, the learning equations of RBM can be introduced as simple form. The distribution of visible state <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/v.png" /> which is marginalized over the hidden state <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h.png" /> is as following:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/distribution_of_visible_state.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/partition_function.png" /> is a partition function in statistical mechanics or thermodynamics. Let <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/D.png" /> be set of observed data points, then <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/D_defined.png" />. Therefore the gradients on the parameter <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/theta.png" /> of the log-likelihood function are</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/gradients_v_on_the_parameter_theta.png" /></div>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/gradients_h_on_the_parameter_theta.png" /></div>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/gradients_w_on_the_parameter_theta.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/expected_value.png" /> is an expected value for <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/p_x_theta.png" />. <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/sig.png" /> is a sigmoid function.</p>
<p>The learning equations of RBM are introduced by performing control so that those gradients can become zero.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/learning_equation_of_RBM.png" /></div></div>
<div class="section" id="contrastive-divergence-as-an-approximation-method">
<span id="contrastive-divergence-as-an-approximation-method"></span><h3>Contrastive Divergence as an approximation method.<a class="headerlink" href="#contrastive-divergence-as-an-approximation-method" title="Permalink to this headline">¶</a></h3>
<p>In relation to RBM, <strong>Contrastive Divergence</strong>(CD) is a method for approximation of the gradients of the log-likelihood(Hinton, G. E. 2002). The procedure of this method is similar to Markov Chain Monte Carlo method(MCMC). However, unlike MCMC, the visbile variables to be set first in visible layer is not randomly initialized but the observed data points in training dataset are set to the first visbile variables. And, like Gibbs sampler, drawing samples from hidden variables and visible variables is repeated <code class="docutils literal notranslate"><span class="pre">k</span></code> times. Empirically (and surprisingly), <code class="docutils literal notranslate"><span class="pre">k</span></code> is considered to be <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div>
<div class="section" id="the-structure-of-dbm">
<span id="the-structure-of-dbm"></span><h3>The structure of DBM.<a class="headerlink" href="#the-structure-of-dbm" title="Permalink to this headline">¶</a></h3>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/image_dbn_and_dbm.png" />
<p>Salakhutdinov, R., Hinton, G. E. (2009). Deep boltzmann machines. In International conference on artificial intelligence and statistics (pp. 448-455). p451.</p>
</div><p>As is well known, DBM is composed of layers of RBMs stacked on top of each other(Salakhutdinov, R., &amp; Hinton, G. E. 2009). This model is a structural expansion of Deep Belief Networks(DBN), which is known as one of the earliest models of Deep Learning(Le Roux, N., &amp; Bengio, Y. 2008). Like RBM, DBN places nodes in layers. However, only the uppermost layer is composed of undirected edges, and the other consists of directed edges. DBN with <code class="docutils literal notranslate"><span class="pre">R</span></code> hidden layers is below probabilistic model:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbn_model.png" /></div><p>where <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">0</span></code> points to visible layer. Considerling simultaneous distribution in top two layer,</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbn_top_two_layer_joint.png" /></div><p>and conditional distributions in other layers are as follows:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbn_other_layers.png" /></div><p>The pre-learning of DBN engages in a procedure of recursive learning in layer-by-layer. However, as you can see from the difference of graph structure, DBM is slightly different from DBN in the form of pre-learning. For instance, if <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">1</span></code>, the conditional distribution of visible layer is</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/conditional_distribution_of_visible_layer.png" />.</div><p>On the other hand, the conditional distribution in the intermediate layer is</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbm_other_hidden_layer.png" /></div><p>where <code class="docutils literal notranslate"><span class="pre">2</span></code> has been introduced considering that the intermediate layer <code class="docutils literal notranslate"><span class="pre">r</span></code> receives input data from Shallower layer
<code class="docutils literal notranslate"><span class="pre">r-1</span></code> and deeper layer <code class="docutils literal notranslate"><span class="pre">r+1</span></code>. DBM sets these parameters as initial states.</p>
</div>
<div class="section" id="dbm-as-a-stacked-auto-encoder">
<span id="dbm-as-a-stacked-auto-encoder"></span><h3>DBM as a Stacked Auto-Encoder.<a class="headerlink" href="#dbm-as-a-stacked-auto-encoder" title="Permalink to this headline">¶</a></h3>
<p>DBM is functionally equivalent to a <strong>Stacked Auto-Encoder</strong>, which is-a neural network that tries to reconstruct its input. To <em>encode</em> the observed data points, the function of DBM is as linear transformation of feature map below</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbm_encoder.png" />.</div><p>On the other hand, to <em>decode</em> this feature points, the function of DBM is as linear transformation of feature map below</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/dbm_decoder.png" />.</div><p>The reconstruction error should be calculated in relation to problem setting. This library provides a default method, which can be overridden, for error function that computes Mean Squared Error(MSE). For instance, my jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_stacked_auto_encoder.ipynb">demo/demo_stacked_auto_encoder.ipynb</a> demonstrates the reconstruction errors of DBM which is a Stacked Auto-Encoder.</p>
</div>
<div class="section" id="structural-expansion-for-rtrbm">
<span id="structural-expansion-for-rtrbm"></span><h3>Structural expansion for RTRBM.<a class="headerlink" href="#structural-expansion-for-rtrbm" title="Permalink to this headline">¶</a></h3>
<p>The <strong>RTRBM</strong> (Sutskever, I., et al. 2009) is a probabilistic time-series model which can be viewed as a temporal stack of RBMs, where each RBM has a contextual hidden state that is received from the previous RBM and is used to modulate its hidden units bias. Let <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/previous_step_h.png" /> be the hidden state in previous step <code class="docutils literal notranslate"><span class="pre">t-1</span></code>. The conditional distribution in hidden layer in time <code class="docutils literal notranslate"><span class="pre">t</span></code> is</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/rtrbm_model.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_R.png" /> is weight matrix in each time steps. Then sampling of observed data points is is as following:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/rtrbm_prob_model.png" /></div><p>While the hidden units are binary during inference and sampling, it is the mean-field value <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_t.png" /> that is transmitted to its successors.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_rtrbm.png" /></div></div>
<div class="section" id="structural-expansion-for-rnn-rbm">
<span id="structural-expansion-for-rnn-rbm"></span><h3>Structural expansion for RNN-RBM.<a class="headerlink" href="#structural-expansion-for-rnn-rbm" title="Permalink to this headline">¶</a></h3>
<p>The RTRBM can be understood as a sequence of conditional RBMs whose parameters are the output of a deterministic RNN, with the constraint that the hidden units must describe the conditional distributions and convey temporal information. This constraint can be lifted by combining a full RNN with distinct hidden units. <strong>RNN-RBM</strong> (Boulanger-Lewandowski, N., et al. 2012), which is the more structural expansion of RTRBM, has also hidden units <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_t.png" />.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/rtrbm_and_rnn-rbm.png" />
<p>Boulanger-Lewandowski, N., Bengio, Y., & Vincent, P. (2012). Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription. arXiv preprint arXiv:1206.6392., p4.</p>
<p>Single arrows represent a deterministic function, double arrows represent the stochastic hidden-visible connections of an RBM.</p>
</div><p>The biases are linear function of <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_t.png" />. This hidden units are only connected to their direct predecessor <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_t_1.png" /> and visible units in time <code class="docutils literal notranslate"><span class="pre">t</span></code> by the relation:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/hat_h_relation.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_2.png" /> and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_3.png" /> are weight matrixes.</p>
</div>
<div class="section" id="structural-expansion-for-lstm-rtrbm">
<span id="structural-expansion-for-lstm-rtrbm"></span><h3>Structural expansion for LSTM-RTRBM.<a class="headerlink" href="#structural-expansion-for-lstm-rtrbm" title="Permalink to this headline">¶</a></h3>
<p>An example of the application to polyphonic music generation(Lyu, Q., et al. 2015) clued me in on how is it possible to connect RTRBM with LSTM.</p>
<div class="section" id="structure-of-lstm">
<span id="structure-of-lstm"></span><h4>Structure of LSTM.<a class="headerlink" href="#structure-of-lstm" title="Permalink to this headline">¶</a></h4>
<p>Originally, Long Short-Term Memory(LSTM) networks as a special RNN structure has proven stable and
powerful for modeling long-range dependencies. The Key point of structural expansion is its memory cell <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/c_t.png" /> which essentially acts as an accumulator of the state information. Every time observed data points are given as new information <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/g_t.png" /> and input to LSTM’s input gate, its information will be accumulated to the cell if the input gate <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/i_t.png" /> is activated. The past state of cell <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/c_t-1.png" /> could be forgotten in this process if LSTM’s forget gate <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/f_t.png" /> is on. Whether the latest cell output <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/c_t.png" /> will be propagated to the final state <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_t.png" /> is further controlled by the output gate <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/o_t.png" />.</p>
<p>Omitting so-called peephole connection, it makes possible to combine the activations in LSTM gates into an affine transformation below.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_affine.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_lstm.png" /> is a weight matrix which connects observed data points and hidden units in LSTM gates, and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/u.png" /> is a weight matrix which connects hidden units as a remembered memory in LSTM gates. Furthermore, activation functions are as follows:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_given.png" /></div><div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_input_gate.png" /></div><div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_forget_gate.png" /></div><div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_output_gate.png" /></div><p>and the acitivation of memory cell and hidden units are calculated as follows:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_memory_cell.png" /></div><div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/lstm_hidden_activity.png" /></div></div>
<div class="section" id="structure-of-lstm-rtrbm">
<span id="structure-of-lstm-rtrbm"></span><h4>Structure of LSTM-RTRBM.<a class="headerlink" href="#structure-of-lstm-rtrbm" title="Permalink to this headline">¶</a></h4>
<p><strong>LSTM-RTRBM</strong> model integrates the ability of LSTM in memorizing and retrieving useful history information, together with the advantage of RBM in high dimensional data modelling(Lyu, Q., Wu, Z., Zhu, J., &amp; Meng, H. 2015, June). Like RTRBM, LSTM-RTRBM also has the recurrent hidden units. Let <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/pre_hidden_units.png" /> be previous hidden units. The conditional distribution of the current hidden layer is as following:</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/LSTM-RTRBM_current_hidden_distribution.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_R.png" /> is a weight matrix which indicates the connectivity between states at each time step in RBM. Now, sampling the observed data points <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/v_T.png" /> in RTRBM is as follows.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/LSTM-RTRBM_sampling_v_T.png" /></div><blockquote>
<div>“Adding LSTM units to RTRBM is not trivial, considering RTRBM’s hidden units and visible units are intertwined in inference and learning. The simplest way to circumvent this difficulty is to use bypass connections from LSTM units to the hidden units besides the existing recurrent connections of hidden units, as in LSTM-RTRBM.”</div></blockquote>
<div>Lyu, Q., Wu, Z., & Zhu, J. (2015, October). Polyphonic music modelling with LSTM-RTRBM. In Proceedings of the 23rd ACM international conference on Multimedia (pp. 991-994). ACM., p.993.</div><p>Therefore it is useful to introduce a distinction of <em>channel</em> which means the sequential information. <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_R.png" /> indicates the direct connectivity in RBM, while <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/W_L.png" /> can be defined as a concept representing the previous time step combination in the LSTM units. Let <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_R.png" /> and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_R.png" /> be the hidden units indicating short-term memory and long-term memory, respectively. Then sampling the observed data points <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/v_T.png" /> in LSTM-RTRBM can be re-described as follows.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/LSTM-RTRBM_sampling_v_T_redescribed.png" /></div></div>
</div>
<div class="section" id="structural-expansion-for-shape-bm">
<span id="structural-expansion-for-shape-bm"></span><h3>Structural expansion for Shape-BM.<a class="headerlink" href="#structural-expansion-for-shape-bm" title="Permalink to this headline">¶</a></h3>
<p>The concept of <strong>Shape Boltzmann Machine</strong> (Eslami, S. A., et al. 2014) provided inspiration to this library. This model uses below has two layers of hidden variables: <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_1.png" /> and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_2.png" />. The visible units <code class="docutils literal notranslate"><span class="pre">v</span></code> arethe pixels of a binary image of size <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/N_times_M.png" />. In the visible layer we enforce local receptive fields by connecting each hidden unit in <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/h_1.png" /> only to a subset of the visible units, corresponding to one of four rectangular patches. In order to encourage boundary consistency each patch overlaps its neighbor by <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/r.png" /> pixels and so has side lengths of <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/n_2_r_2.png" /> and <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/m_2_r_2.png" />. In this model, the weight matrix in visible and hidden layer correspond to conectivity between the four sets of hidden units and patches, however the visible biases <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/b_i.png" /> are not shared.</p>
<div align="center">
 <table style="border: none;">
  <tr>
   <td width="45%" align="center">
        <div>
        <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/shape-bm-3d.png" />
        <p>Eslami, S. A., Heess, N., Williams, C. K., & Winn, J. (2014). The shape boltzmann machine: a strong model of object shape. International Journal of Computer Vision, 107(2), 155-176., p156.</p>
        </div>
   </td>
   <td width="45%" align="center">
        <div>
        <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/sbm_network.png" />
        <p>Eslami, S. A., Heess, N., Williams, C. K., & Winn, J. (2014). The shape boltzmann machine: a strong model of object shape. International Journal of Computer Vision, 107(2), 155-176., p156.</p>
        </div>
   </td>
  </tr>
 </table>
</div><p>The Shape-BM is a DBM in three layer. The learning algorithm can be completed by optimization of</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/sbm_prob.png" /></div><p>where <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/sbm_params.png" />.</p>
</div>
<div class="section" id="the-commonality-variability-analysis-in-order-to-practice-object-oriented-design">
<span id="the-commonality-variability-analysis-in-order-to-practice-object-oriented-design"></span><h3>The Commonality/Variability Analysis in order to practice object-oriented design.<a class="headerlink" href="#the-commonality-variability-analysis-in-order-to-practice-object-oriented-design" title="Permalink to this headline">¶</a></h3>
<p>From perspective of <em>commonality/variability analysis</em> in order to practice object-oriented design, the concepts of RBM and DBM paradigms can be organized as follows:</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/draw.io/pydbm_dbm_class_diagram.png?1" /></p>
<p>Pay attention to the interface of the above class diagram. While each model is <em>common</em> in that it is constituted by stacked RBM, its approximation methods and activation functions are <em>variable</em> depending on the problem settings.</p>
<p>Considering the <em>commonality</em>, it is useful to design based on <code class="docutils literal notranslate"><span class="pre">Builder</span> <span class="pre">Pattern</span></code> represented by <code class="docutils literal notranslate"><span class="pre">DBMBuilder</span></code> or <code class="docutils literal notranslate"><span class="pre">RTRBMBuilder</span></code>, which separates the construction of RBM object <code class="docutils literal notranslate"><span class="pre">RestrictedBoltzmannMachine</span></code> from its representation by <code class="docutils literal notranslate"><span class="pre">DBMDirector</span></code> or <code class="docutils literal notranslate"><span class="pre">RTRBMDirector</span></code> so that the same construction process can create different representations such as DBM, RTRBM, RNN-RBM, and Shape-BM. Additionally, the models of all neural networks are <em>common</em> in that they possess like synapses by obtaining computation graphs without exception. So the class <code class="docutils literal notranslate"><span class="pre">Synapse</span></code> is contained in various models in a state where computation graphs of weight matrix and bias vector are held in the field.</p>
<p>On the other hand, to deal with the <em>variability</em>, <code class="docutils literal notranslate"><span class="pre">Strategy</span> <span class="pre">Pattern</span></code>, which provides a way to define a family of algorithms such as approximation methods implemented by inheriting the interface <code class="docutils literal notranslate"><span class="pre">ApproximateInterface</span></code>, and also activation functions implemented by inheriting the interface <code class="docutils literal notranslate"><span class="pre">ActivatingFunctionInterface</span></code>, is useful design method, which is encapsulate each one as an object, and make them interchangeable from the point of view of functionally equivalent. <code class="docutils literal notranslate"><span class="pre">Template</span> <span class="pre">Method</span> <span class="pre">Pattern</span></code> is also useful design method to design the optimizer in this library because this design pattern makes it possible to define the skeleton of an algorithm in a parameter tuning, deferring some steps to client subclasses such as <code class="docutils literal notranslate"><span class="pre">SGD</span></code>, <code class="docutils literal notranslate"><span class="pre">AdaGrad</span></code>, <code class="docutils literal notranslate"><span class="pre">RMSProp</span></code>, <code class="docutils literal notranslate"><span class="pre">NAG</span></code>,  <code class="docutils literal notranslate"><span class="pre">Adam</span></code> or <code class="docutils literal notranslate"><span class="pre">Nadam</span></code>. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</div>
<div class="section" id="functionally-equivalent-encoder-decoder-based-on-lstm">
<span id="functionally-equivalent-encoder-decoder-based-on-lstm"></span><h3>Functionally equivalent: Encoder/Decoder based on LSTM.<a class="headerlink" href="#functionally-equivalent-encoder-decoder-based-on-lstm" title="Permalink to this headline">¶</a></h3>
<p>The methodology of <em>equivalent-functionalism</em> enables us to introduce more functional equivalents and compare problem solutions structured with different algorithms and models in common problem setting. For example, in dimension reduction problem, the function of <strong>Encoder/Decoder schema</strong> is equivalent to <strong>DBM</strong> as a <strong>Stacked Auto-Encoder</strong>.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/latex/encoder_decoder.png" />
<p>Cho, K., Van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., & Bengio, Y. (2014). Learning phrase representations using RNN encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078., p2.</p>
</div><p>According to the neural networks theory, and in relation to manifold hypothesis, it is well known that multilayer neural networks can learn features of observed data points and have the feature points in hidden layer. High-dimensional data can be converted to low-dimensional codes by training the model such as <strong>Stacked Auto-Encoder</strong> and <strong>Encoder/Decoder</strong> with a small central layer to reconstruct high-dimensional input vectors. This function of dimensionality reduction facilitates feature expressions to calculate similarity of each data point.</p>
<p>This library provides <strong>Encoder/Decoder based on LSTM</strong>, which is a reconstruction model and makes it possible to extract series features embedded in deeper layers. The LSTM encoder learns a fixed length vector of time-series observed data points and the LSTM decoder uses this representation to reconstruct the time-series using the current hidden state and the value inferenced at the previous time-step.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/draw.io/pydbm_rnn_class_diagram.png" /></p>
<p>As in the above class diagram, in this library, the class <code class="docutils literal notranslate"><span class="pre">EncoderDecoderController</span></code> can be composed of two <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code>s. <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code> is-a <code class="docutils literal notranslate"><span class="pre">ReconstructableModel</span></code>, which has a learning method and an inference method like the ordinary supervised learning model.</p>
<p>An example is illustrated in this my jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb">demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb</a>. This notebook demonstrates a simple sine wave prediction by Encoder/Decoder based on LSTM.</p>
<div class="section" id="encoder-decoder-for-anomaly-detection-encdec-ad">
<span id="encoder-decoder-for-anomaly-detection-encdec-ad"></span><h4>Encoder/Decoder for Anomaly Detection(EncDec-AD)<a class="headerlink" href="#encoder-decoder-for-anomaly-detection-encdec-ad" title="Permalink to this headline">¶</a></h4>
<p>One interesting application example is the <strong>Encoder/Decoder for Anomaly Detection (EncDec-AD)</strong> paradigm (Malhotra, P., et al. 2016). This reconstruction model learns to reconstruct <em>normal</em> time-series behavior, and thereafter uses reconstruction error to detect anomalies. Malhotra, P., et al. (2016) showed that EncDec-AD paradigm is robust and can detect anomalies from predictable, unpredictable, periodic, aperiodic, and quasi-periodic time-series. Further, they showed that the paradigm is able to detect anomalies from short time-series (length as small as 30) as well as long time-series (length as large as 500).</p>
<p>As the prototype is exemplified in <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_anomaly_detection_by_enc_dec_ad.ipynb">demo/demo_anomaly_detection_by_enc_dec_ad.ipynb</a>, this library provides Encoder/Decoder based on LSTM as a EncDec-AD scheme.</p>
</div>
</div>
<div class="section" id="functionally-equivalent-convolutional-auto-encoder">
<span id="functionally-equivalent-convolutional-auto-encoder"></span><h3>Functionally equivalent: Convolutional Auto-Encoder.<a class="headerlink" href="#functionally-equivalent-convolutional-auto-encoder" title="Permalink to this headline">¶</a></h3>
<p><strong>Shape-BM</strong> is a kind of problem solution in relation to problem settings such as image segmentation, object detection, inpainting and graphics. In this problem settings, <strong>Convolutional Auto-Encoder</strong>(Masci, J., et al., 2011) is a functionally equivalent of <strong>Shape-BM</strong>. A stack of Convolutional Auto-Encoder forms a convolutional neural network(CNN), which are among the most successful models for supervised image classification. Each Convolutional Auto-Encoder is trained using conventional on-line gradient descent without additional regularization terms.</p>
<table border="0">
    <tr>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/horse099.jpg" />
        <p>Image in <a href="https://avaminzhang.wordpress.com/2012/12/07/%E3%80%90dataset%E3%80%91weizmann-horses/" target="_blank">the Weizmann horse dataset</a>.</p>
        </td>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/reconstructed_horse099.gif" />
            <p>Reconstructed image by <strong>Shape-BM</strong>.</p>
        </td>
        <td>
            <img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/reconstructed_by_CAE.gif" />
            <p>Reconstructed image by <strong>Convolutional Auto-Encoder</strong>.</p>
        </td>
    </tr>
</table><p>My jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_convolutional_auto_encoder.ipynb">demo/demo_convolutional_auto_encoder.ipynb</a> also demonstrates various reconstructed images.</p>
<p>This library can draw a distinction between <strong>Stacked Auto-Encoder</strong> and <strong>Convolutional Auto-Encoder</strong>, and is able to design and implement respective models. <strong>Stacked Auto-Encoder</strong> ignores the 2 dimentional image structures. In many cases, the rank of observed tensors extracted from image dataset is more than 3. This is not only a problem when dealing with realistically sized inputs, but also introduces redundancy in the parameters, forcing each feature to be global. Like <strong>Shape-BM</strong>, <strong>Convolutional Auto-Encoder</strong> differs from <strong>Stacked Auto-Encoder</strong> as their weights are shared among all locations in the input, preserving spatial locality. Hence, the reconstructed image data is due to a linear combination of basic image patches based on the latent code.</p>
<p>In this library, <strong>Convolutional Auto-Encoder</strong> is also based on <strong>Encoder/Decoder</strong> scheme. The <em>encoder</em> is to the <em>decoder</em> what the <em>Convolution</em> is to the <em>Deconvolution</em>. The Deconvolution also called transposed convolutions “work by swapping the forward and backward passes of a convolution.” (Dumoulin, V., &amp; Visin, F. 2016, p20.)</p>
</div>
<div class="section" id="structural-expansion-for-convolutional-lstm-convlstm">
<span id="structural-expansion-for-convolutional-lstm-convlstm"></span><h3>Structural expansion for Convolutional LSTM(ConvLSTM).<a class="headerlink" href="#structural-expansion-for-convolutional-lstm-convlstm" title="Permalink to this headline">¶</a></h3>
<p><strong>Convolutional LSTM(ConvLSTM)</strong>(Xingjian, S. H. I. et al., 2015), which is a model that structurally couples <strong>convolution operators</strong> to <strong>LSTM</strong> networks, can be utilized as components in constructing the Encoder/Decoder. The ConvLSTM is suitable for spatio-temporal data due to its inherent convolutional structure.</p>
<div>
<img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/model_of_conv_lstm.png" />
<p><cite>Xingjian, S. H. I., Chen, Z., Wang, H., Yeung, D. Y., Wong, W. K., & Woo, W. C. (2015). Convolutional LSTM network: A machine learning approach for precipitation nowcasting. In Advances in neural information processing systems (pp. 802-810), p806.</cite></p>
</div><p>This library also makes it possible to build <strong>Encoder/Decoder based on ConvLSTM</strong>. My jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_conv_lstm.ipynb">demo/demo_conv_lstm.ipynb</a> demonstrates that the Encoder/Decoder based on Convolutional LSTM(ConvLSTM) can learn images and reconstruct its.</p>
</div>
<div class="section" id="structural-expansion-for-spatio-temporal-auto-encoder">
<span id="structural-expansion-for-spatio-temporal-auto-encoder"></span><h3>Structural expansion for Spatio-Temporal Auto-Encoder.<a class="headerlink" href="#structural-expansion-for-spatio-temporal-auto-encoder" title="Permalink to this headline">¶</a></h3>
<p><strong>Encoder/Decoder based on ConvLSTM</strong> and <strong>Convolutional Auto-Encoder</strong> have a functional reusability to extend the structures to <strong>Spatio-Temporal Auto-Encoder</strong>, which can learn the regular patterns in the training videos(Baccouche, M., et al., 2012, Patraucean, V., et al. 2015). This model consists of spatial Auto-Encoder and temporal Encoder/Decoder. The spatial Auto-Encoder is a Convolutional Auto-Encoder for learning spatial structures of each video frame. The temporal Encoder/Decoder is an Encoder/Decoder based on LSTM scheme for learning temporal patterns of the encoded spatial structures. The spatial encoder and decoder have two convolutional and deconvolutional layers respectively, while the temporal encoder and decoder are to act as a twin LSTM models.</p>
<div><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/spatio_temporal_auto_encoder_model.png" />
<p>Chong, Y. S., & Tay, Y. H. (2017, June). Abnormal event detection in videos using spatiotemporal autoencoder. In International Symposium on Neural Networks (pp. 189-196). Springer, Cham., p.195.</p>
</div><p>Because of the structural expansions, <strong>ConvLSTM</strong> and <strong>Spatio-Temporal Auto-Encoder</strong> can be consisted by <code class="docutils literal notranslate"><span class="pre">cnn</span></code> subpackage, which is responsible for convolution and deconvolution of spatial features, and <code class="docutils literal notranslate"><span class="pre">rnn</span></code> subpackage for controlling reconstruction of temporal features as in the following class diagram.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/draw.io/pydbm_cnn_class_diagram.png" /></p>
<p>In <code class="docutils literal notranslate"><span class="pre">cnn</span></code> subpackage, the class <code class="docutils literal notranslate"><span class="pre">LayerableCNN</span></code> is an abstract class to implement CNN layers such as <code class="docutils literal notranslate"><span class="pre">ConvolutionLayer</span></code> and <code class="docutils literal notranslate"><span class="pre">MaxPoolingLayer</span></code>. <code class="docutils literal notranslate"><span class="pre">ConvolutionalAutoEncoder</span></code> and <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code> have those CNN layers, especially <code class="docutils literal notranslate"><span class="pre">ConvolutionLayer</span></code> to convolve as forward propagation and to deconvolve as back propagation, and are common in the sense that each class has a learning method and an inference method. The difference is that only <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code> is related to <code class="docutils literal notranslate"><span class="pre">ReconstructableModel</span></code> such as <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code> and <code class="docutils literal notranslate"><span class="pre">ConvLSTMModel</span></code> in <code class="docutils literal notranslate"><span class="pre">rnn</span></code> subpackage.</p>
<div class="section" id="video-recognition-and-reconstruction-of-video-images">
<span id="video-recognition-and-reconstruction-of-video-images"></span><h4>Video recognition and reconstruction of video images.<a class="headerlink" href="#video-recognition-and-reconstruction-of-video-images" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_spatio_temporal_auto_encoder.ipynb">demo/demo_spatio_temporal_auto_encoder.ipynb</a> is a jupyter notebook which demonstrates the video recognition and reconstruction of video images by the Spatio-Temporal Auto-Encoder.</p>
</div>
</div>
<div class="section" id="structural-extension-from-auto-encoders-and-encoder-decoders-to-energy-based-models-and-generative-models">
<span id="structural-extension-from-auto-encoders-and-encoder-decoders-to-energy-based-models-and-generative-models"></span><h3>Structural extension from Auto-Encoders and Encoder/Decoders to energy-based models and Generative models.<a class="headerlink" href="#structural-extension-from-auto-encoders-and-encoder-decoders-to-energy-based-models-and-generative-models" title="Permalink to this headline">¶</a></h3>
<p>Auto-Encoders, such as the Convolutional Auto-Encoder, the Spatio-Temporal Auto-Encoder, and the DBM have in common that these models are Stacked Auto-Encoders. And the Encoder/Decoder based on LSTM or ConvLSTM share similarity with the RTRBM, RNN-RBM, and LSTM-RTRBM, as the reconstruction models. On the other hand, the Auto-Encoders and the Encoder/Decoders are not statistical mechanical energy-based models unlike with RBM or DBM.</p>
<p>However, Auto-Encoders have traditionally been used to represent energy-based models. According to the statistical mechanical theory for energy-based models, Auto-Encoders constructed by neural networks can be associated with an energy landscape, akin to negative log-probability in a probabilistic model, which measures how well the Auto-Encoder can represent regions in the input space. The energy landscape has been commonly inferred heuristically, by using a training criterion that relates the Auto-Encoder to a probabilistic model such as a RBM. The energy function is identical to the free energy of the corresponding RBM, showing that Auto-Encoders and RBMs may be viewed as two different ways to derive training criteria for forming the same type of analytically defined energy landscape.</p>
<p>The view of the Auto-Encoder as a dynamical system allows us to understand how an energy function may be derived for the Auto-Encoder. This makes it possible to assign energies to Auto-Encoders with many different types of activation functions and outputs, and consider minimanization of reconstruction errors as energy minimanization(Kamyshanska, H., &amp; Memisevic, R., 2014).</p>
<p>When trained with some regularization terms, the Auto-Encoders have the ability to learn an energy manifold without supervision or negative examples(Zhao, J., et al., 2016). This means that even when an energy-based Auto-Encoding model is trained to reconstruct a real sample, the model contributes to discovering the data manifold by itself.</p>
<p>This library provides energy-based Auto-Encoders such as Contractive Convolutional Auto-Encoder(Rifai, S., et al., 2011), Repelling Convolutional Auto-Encoder(Zhao, J., et al., 2016), Denoising Auto-Encoders(Bengio, Y., et al., 2013), and Ladder Networks(Valpola, H., 2015). But it is more usefull to redescribe the Auto-Encoders in the framework of Generative Adversarial Networks(GANs)(Goodfellow, I., et al., 2014) to make those models function as not only energy-based models but also Generative models. For instance, theory of an Adversarial Auto-Encoders(AAEs)(Makhzani, A., et al., 2015) and energy-based GANs(EBGANs)(Zhao, J., et al., 2016) enables us to turn Auto-Encoders into a Generative models which referes energy functions. If you want to implement GANs and AAEs by using <code class="docutils literal notranslate"><span class="pre">pydbm</span></code> as components for Generative models based on the Statistical machine learning problems, see <a class="reference external" href="https://github.com/chimera0/accel-brain-code/tree/master/Generative-Adversarial-Networks">Generative Adversarial Networks Library: pygan</a>.</p>
</div>
<div class="section" id="composition-and-correspondence-in-this-library">
<span id="composition-and-correspondence-in-this-library"></span><h3>Composition and Correspondence in this library<a class="headerlink" href="#composition-and-correspondence-in-this-library" title="Permalink to this headline">¶</a></h3>
<p>To summarize the information so far into one class diagram, the outline is as follows.</p>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/draw.io/pydbm_all_subpackage_class_diagram.png" /></p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">dbm</span></code> subpackage, <code class="docutils literal notranslate"><span class="pre">rnn</span></code> subpackage and <code class="docutils literal notranslate"><span class="pre">cnn</span></code> subpackage have an association with the interface <code class="docutils literal notranslate"><span class="pre">ComputableLoss</span></code>. The subclass are Loss functions such as Mean Square Error(MSE) and Cross Entropy. The <em>function</em> of loss functions for <code class="docutils literal notranslate"><span class="pre">dbm</span></code> is included in the <em>function</em> of energy functions optimized to minimize cost in the interface <code class="docutils literal notranslate"><span class="pre">ApproximateInterface</span></code>.</p>
<p><a name="usecase_building_the_deep_boltzmann_machine_for_feature_extracting"></a></p>
</div>
</div>
<div class="section" id="usecase-building-the-deep-boltzmann-machine-for-feature-extracting">
<span id="usecase-building-the-deep-boltzmann-machine-for-feature-extracting"></span><h2>Usecase: Building the Deep Boltzmann Machine for feature extracting.<a class="headerlink" href="#usecase-building-the-deep-boltzmann-machine-for-feature-extracting" title="Permalink to this headline">¶</a></h2>
<p>Import Python and Cython modules based on Builder Pattern.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.deep_boltzmann_machine</span> <span class="kn">import</span> <span class="n">DeepBoltzmannMachine</span>
<span class="c1"># The `Concrete Builder` in Builder Pattern.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.builders.dbm_multi_layer_builder</span> <span class="kn">import</span> <span class="n">DBMMultiLayerBuilder</span>
<span class="c1"># Contrastive Divergence for function approximation.</span>
<span class="kn">from</span> <span class="nn">pydbm.approximation.contrastive_divergence</span> <span class="kn">import</span> <span class="n">ContrastiveDivergence</span>
</pre></div>
</div>
<p>Import Python and Cython modules of activation functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Logistic Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.logistic_function</span> <span class="kn">import</span> <span class="n">LogisticFunction</span>
<span class="c1"># Tanh Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.tanh_function</span> <span class="kn">import</span> <span class="n">TanhFunction</span>
<span class="c1"># ReLu Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.relu_function</span> <span class="kn">import</span> <span class="n">ReLuFunction</span>
</pre></div>
</div>
<p>Import Python and Cython modules of optimizers, and instantiate the objects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Stochastic Gradient Descent(SGD) as optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span>
    <span class="c1"># Momentum.</span>
    <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If you want to use not Stochastic Gradient Descent(SGD) but Adam(Kingma, D. P., &amp; Ba, J., 2014) optimizer, import <code class="docutils literal notranslate"><span class="pre">Adam</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Adam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.adam</span> <span class="kn">import</span> <span class="n">Adam</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span>
    <span class="c1"># BETA 1.</span>
    <span class="n">beta_1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="c1"># BETA 2.</span>
    <span class="n">beta_2</span><span class="o">=</span><span class="mf">0.99</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Setup parameters of regularization. For instance, constraining (or scale down) weight vectors and the probability of dropout(Srivastava, N., Hinton, G., et al., 2014, Zaremba, W., et al., 2014) can be set as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Regularization for weights matrix</span>
<span class="c1"># to repeat multiplying the weights matrix and `0.9`</span>
<span class="c1"># until $\sum_{j=0}^{n}w_{ji}^2 &lt; weight\_limit$.</span>
<span class="n">opt_params</span><span class="o">.</span><span class="n">weight_limit</span> <span class="o">=</span> <span class="mf">1e+03</span>

<span class="c1"># Probability of dropout.</span>
<span class="n">opt_params</span><span class="o">.</span><span class="n">dropout_rate</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>Instantiate objects and call the method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Contrastive Divergence for visible layer and first hidden layer.</span>
<span class="n">first_cd</span> <span class="o">=</span> <span class="n">ContrastiveDivergence</span><span class="p">(</span><span class="n">opt_params</span><span class="o">=</span><span class="n">opt_params</span><span class="p">)</span>
<span class="c1"># Contrastive Divergence for first hidden layer and second hidden layer.</span>
<span class="n">second_cd</span> <span class="o">=</span> <span class="n">ContrastiveDivergence</span><span class="p">(</span><span class="n">opt_params</span><span class="o">=</span><span class="n">opt_params</span><span class="p">)</span>

<span class="c1"># DBM</span>
<span class="n">dbm</span> <span class="o">=</span> <span class="n">DeepBoltzmannMachine</span><span class="p">(</span>
    <span class="c1"># `Concrete Builder` in Builder Pattern,</span>
    <span class="c1"># which composes three restricted boltzmann machines for building a deep boltzmann machine.</span>
    <span class="n">DBMMultiLayerBuilder</span><span class="p">(),</span>
    <span class="c1"># Dimention in visible layer, hidden layer, and second hidden layer.</span>
    <span class="p">[</span><span class="n">train_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="n">train_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="c1"># Setting objects for activation function.</span>
    <span class="p">[</span><span class="n">ReLuFunction</span><span class="p">(),</span> <span class="n">LogisticFunction</span><span class="p">(),</span> <span class="n">TanhFunction</span><span class="p">()],</span>
    <span class="c1"># Setting the object for function approximation.</span>
    <span class="p">[</span><span class="n">first_cd</span><span class="p">,</span> <span class="n">second_cd</span><span class="p">],</span> 
    <span class="c1"># Setting learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.05</span>
<span class="p">)</span>

<span class="c1"># Execute learning.</span>
<span class="n">dbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="c1"># `np.ndarray` of observed data points.</span>
    <span class="n">train_arr</span><span class="p">,</span>
     <span class="c1"># If approximation is the Contrastive Divergence, this parameter is `k` in CD method.</span>
    <span class="n">training_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="c1"># Batch size in mini-batch training.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="c1"># if `r_batch_size` &gt; 0, the function of `dbm.learn` is a kind of reccursive learning.</span>
    <span class="n">r_batch_size</span><span class="o">=-</span><span class="mi">1</span> 
<span class="p">)</span>
</pre></div>
</div>
<p>If you do not want to execute the mini-batch training, the value of <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> must be <code class="docutils literal notranslate"><span class="pre">-1</span></code>. And <code class="docutils literal notranslate"><span class="pre">r_batch_size</span></code> is also parameter to control the mini-batch training but is refered only in inference and reconstruction. If this value is more than <code class="docutils literal notranslate"><span class="pre">0</span></code>,  the inferencing is a kind of reccursive learning with the mini-batch training.</p>
<p>And the feature points can be extracted by this method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">feature_point_arr</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">get_feature_point</span><span class="p">(</span><span class="n">layer_number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><a name="usecase_extracting_all_feature_points_for_dimensions_reduction_or_pre_learning"></a></p>
</div>
<div class="section" id="usecase-extracting-all-feature-points-for-dimensions-reduction-or-pre-learning">
<span id="usecase-extracting-all-feature-points-for-dimensions-reduction-or-pre-learning"></span><h2>Usecase: Extracting all feature points for dimensions reduction(or pre-learning)<a class="headerlink" href="#usecase-extracting-all-feature-points-for-dimensions-reduction-or-pre-learning" title="Permalink to this headline">¶</a></h2>
<p>Import Python and Cython modules and instantiate the objects in the same manner as <a href="#usecase_building_the_deep_boltzmann_machine_for_feature_extracting">Usecase: Building the Deep Boltzmann Machine for feature extracting.</a></p>
<p>Import and instantiate not <code class="docutils literal notranslate"><span class="pre">DeepBoltzmannMachine</span></code> but <code class="docutils literal notranslate"><span class="pre">StackedAutoEncoder</span></code>, and call the method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `StackedAutoEncoder` is-a `DeepBoltzmannMachine`.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.deepboltzmannmachine.stacked_auto_encoder</span> <span class="kn">import</span> <span class="n">StackedAutoEncoder</span>

<span class="c1"># is-a `DeepBoltzmannMachine`.</span>
<span class="n">dbm</span> <span class="o">=</span> <span class="n">StackedAutoEncoder</span><span class="p">(</span>
    <span class="n">DBMMultiLayerBuilder</span><span class="p">(),</span>
    <span class="p">[</span><span class="n">target_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="n">target_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="n">activation_list</span><span class="p">,</span>
    <span class="n">approximaion_list</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.05</span> <span class="c1"># Setting learning rate.</span>
<span class="p">)</span>

<span class="c1"># Execute learning.</span>
<span class="n">dbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="n">target_arr</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="c1"># If approximation is the Contrastive Divergence, this parameter is `k` in CD method.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>  <span class="c1"># Batch size in mini-batch training.</span>
    <span class="n">r_batch_size</span><span class="o">=-</span><span class="mi">1</span>  <span class="c1"># if `r_batch_size` &gt; 0, the function of `dbm.learn` is a kind of reccursive learning.</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The function of <code class="docutils literal notranslate"><span class="pre">computable_loss</span></code> is computing the reconstruction error. <code class="docutils literal notranslate"><span class="pre">MeanSquaredError</span></code> is-a <code class="docutils literal notranslate"><span class="pre">ComputableLoss</span></code>, which is so-called Loss function.</p>
<div class="section" id="extract-reconstruction-error-rate">
<span id="extract-reconstruction-error-rate"></span><h3>Extract reconstruction error rate.<a class="headerlink" href="#extract-reconstruction-error-rate" title="Permalink to this headline">¶</a></h3>
<p>You can check the reconstruction error rate. During the approximation of the Contrastive Divergence, the mean squared error(MSE) between the observed data points and the activities in visible layer is computed as the reconstruction error rate.</p>
<p>Call <code class="docutils literal notranslate"><span class="pre">get_reconstruct_error_arr</span></code> method as follow.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reconstruct_error_arr</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">get_reconstruct_error_arr</span><span class="p">(</span><span class="n">layer_number</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">layer_number</span></code> corresponds to the index of <code class="docutils literal notranslate"><span class="pre">approximaion_list</span></code>. And <code class="docutils literal notranslate"><span class="pre">reconstruct_error_arr</span></code> is the <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of reconstruction error rates.</p>
</div>
<div class="section" id="extract-the-result-of-dimention-reduction">
<span id="extract-the-result-of-dimention-reduction"></span><h3>Extract the result of dimention reduction<a class="headerlink" href="#extract-the-result-of-dimention-reduction" title="Permalink to this headline">¶</a></h3>
<p>And the result of dimention reduction can be extracted by this property.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_learned_arr</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">feature_points_arr</span>
</pre></div>
</div>
</div>
<div class="section" id="extract-weights-obtained-by-pre-learning">
<span id="extract-weights-obtained-by-pre-learning"></span><h3>Extract weights obtained by pre-learning.<a class="headerlink" href="#extract-weights-obtained-by-pre-learning" title="Permalink to this headline">¶</a></h3>
<p>If you want to get the pre-learning weights, call <code class="docutils literal notranslate"><span class="pre">get_weight_arr_list</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">weight_arr_list</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">get_weight_arr_list</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">weight_arr_list</span></code> is the <code class="docutils literal notranslate"><span class="pre">list</span></code> of weights of each links in DBM. <code class="docutils literal notranslate"><span class="pre">weight_arr_list[0]</span></code> is 2-d <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of weights between visible layer and first hidden layer.</p>
</div>
<div class="section" id="extract-biases-obtained-by-pre-learning">
<span id="extract-biases-obtained-by-pre-learning"></span><h3>Extract biases obtained by pre-learning.<a class="headerlink" href="#extract-biases-obtained-by-pre-learning" title="Permalink to this headline">¶</a></h3>
<p>Call <code class="docutils literal notranslate"><span class="pre">get_visible_bias_arr_list</span></code> method and <code class="docutils literal notranslate"><span class="pre">get_hidden_bias_arr_list</span></code> method in the same way.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">visible_bias_arr_list</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">get_visible_bias_arr_list</span><span class="p">()</span>
<span class="n">hidden_bias_arr_list</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">get_hidden_bias_arr_list</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">visible_bias_arr_list</span></code> and <code class="docutils literal notranslate"><span class="pre">hidden_bias_arr_list</span></code> are the <code class="docutils literal notranslate"><span class="pre">list</span></code> of biases of each links in DBM.</p>
</div>
<div class="section" id="save-pre-learned-parameters">
<span id="save-pre-learned-parameters"></span><h3>Save pre-learned parameters.<a class="headerlink" href="#save-pre-learned-parameters" title="Permalink to this headline">¶</a></h3>
<p>The object <code class="docutils literal notranslate"><span class="pre">dbm</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">DeepBoltzmannMachine</span></code>, has the method <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code>, to store the pre-learned parameters in compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> files.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save pre-learned parameters.</span>
<span class="n">dbm</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span>
    <span class="c1"># Path of dir. If `None`, the file is saved in the current directory.</span>
    <span class="n">dir_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/&quot;</span><span class="p">,</span>
    <span class="c1"># The naming rule of files. If `None`, this value is `dbm`.</span>
    <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;demo_dbm&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transfer-learning-in-dbm">
<span id="transfer-learning-in-dbm"></span><h3>Transfer learning in DBM.<a class="headerlink" href="#transfer-learning-in-dbm" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">DBMMultiLayerBuilder</span></code> can be given <code class="docutils literal notranslate"><span class="pre">pre_learned_path_list</span></code> which is a <code class="docutils literal notranslate"><span class="pre">list</span></code> of file paths that store pre-learned parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dbm</span> <span class="o">=</span> <span class="n">StackedAutoEncoder</span><span class="p">(</span>
    <span class="n">DBMMultiLayerBuilder</span><span class="p">(</span>
        <span class="c1"># `list` of file path that stores pre-learned parameters.</span>
        <span class="n">pre_learned_path_list</span><span class="o">=</span><span class="p">[</span>
            <span class="s2">&quot;/var/tmp/demo_dbm_0.npz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;/var/tmp/demo_dbm_1.npz&quot;</span>
        <span class="p">]</span>
    <span class="p">),</span>
    <span class="p">[</span><span class="n">next_target_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="n">next_target_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="n">activation_list</span><span class="p">,</span>
    <span class="n">approximaion_list</span><span class="p">,</span>
    <span class="c1"># Setting learning rate.</span>
    <span class="mf">0.05</span>
<span class="p">)</span>

<span class="c1"># Execute learning.</span>
<span class="n">dbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="n">next_target_arr</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="c1"># If approximation is the Contrastive Divergence, this parameter is `k` in CD method.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>  <span class="c1"># Batch size in mini-batch training.</span>
    <span class="n">r_batch_size</span><span class="o">=-</span><span class="mi">1</span>  <span class="c1"># if `r_batch_size` &gt; 0, the function of `dbm.learn` is a kind of reccursive learning.</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If you want to know how to minimize the reconstructed error, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_stacked_auto_encoder.ipynb">demo/demo_stacked_auto_encoder.ipynb</a>.</p>
</div>
<div class="section" id="performance">
<span id="performance"></span><h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>Run a program: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/test/demo_stacked_auto_encoder.py">test/demo_stacked_auto_encoder.py</a></p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">time</span> python test/demo_stacked_auto_encoder.py
</pre></div>
</div>
<p>The result is follow.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>real    1m59.875s
user    1m30.642s
sys     0m29.232s
</pre></div>
</div>
<div class="section" id="detail">
<span id="detail"></span><h4>Detail<a class="headerlink" href="#detail" title="Permalink to this headline">¶</a></h4>
<p>This experiment was performed under the following conditions.</p>
<div class="section" id="machine-type">
<span id="machine-type"></span><h5>Machine type<a class="headerlink" href="#machine-type" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>vCPU: <code class="docutils literal notranslate"><span class="pre">2</span></code></li>
<li>memory: <code class="docutils literal notranslate"><span class="pre">8GB</span></code></li>
<li>CPU Platform: Intel Ivy Bridge</li>
</ul>
</div>
<div class="section" id="observation-data-points">
<span id="observation-data-points"></span><h5>Observation Data Points<a class="headerlink" href="#observation-data-points" title="Permalink to this headline">¶</a></h5>
<p>The observated data is the result of <code class="docutils literal notranslate"><span class="pre">np.random.normal(loc=0.5,</span> <span class="pre">scale=0.2,</span> <span class="pre">size=(10000,</span> <span class="pre">10000))</span></code>.</p>
</div>
<div class="section" id="number-of-units">
<span id="number-of-units"></span><h5>Number of units<a class="headerlink" href="#number-of-units" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Visible layer: <code class="docutils literal notranslate"><span class="pre">10000</span></code></li>
<li>hidden layer(feature point): <code class="docutils literal notranslate"><span class="pre">10</span></code></li>
<li>hidden layer: <code class="docutils literal notranslate"><span class="pre">10000</span></code></li>
</ul>
</div>
<div class="section" id="activation-functions">
<span id="activation-functions"></span><h5>Activation functions<a class="headerlink" href="#activation-functions" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>visible:                Logistic Function</li>
<li>hidden(feature point):  Logistic Function</li>
<li>hidden:                 Logistic Function</li>
</ul>
</div>
<div class="section" id="approximation">
<span id="approximation"></span><h5>Approximation<a class="headerlink" href="#approximation" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Contrastive Divergence</li>
</ul>
</div>
<div class="section" id="hyper-parameters">
<span id="hyper-parameters"></span><h5>Hyper parameters<a class="headerlink" href="#hyper-parameters" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Learning rate: <code class="docutils literal notranslate"><span class="pre">0.05</span></code></li>
<li>Dropout rate: <code class="docutils literal notranslate"><span class="pre">0.5</span></code></li>
</ul>
</div>
<div class="section" id="feature-points">
<span id="feature-points"></span><h5>Feature points<a class="headerlink" href="#feature-points" title="Permalink to this headline">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">0.092057</span>   <span class="mf">0.08856277</span> <span class="mf">0.08699257</span> <span class="o">...</span> <span class="mf">0.09167331</span> <span class="mf">0.08937846</span> <span class="mf">0.0880063</span> <span class="p">]</span>
 <span class="p">[</span><span class="mf">0.09090537</span> <span class="mf">0.08669612</span> <span class="mf">0.08995347</span> <span class="o">...</span> <span class="mf">0.08641837</span> <span class="mf">0.08750935</span> <span class="mf">0.08617442</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.10187259</span> <span class="mf">0.10633451</span> <span class="mf">0.10060372</span> <span class="o">...</span> <span class="mf">0.10170306</span> <span class="mf">0.10711189</span> <span class="mf">0.10565192</span><span class="p">]</span>
 <span class="o">...</span>
 <span class="p">[</span><span class="mf">0.21540273</span> <span class="mf">0.21737737</span> <span class="mf">0.20949192</span> <span class="o">...</span> <span class="mf">0.20974982</span> <span class="mf">0.2208562</span>  <span class="mf">0.20894371</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.30749327</span> <span class="mf">0.30964707</span> <span class="mf">0.2850683</span>  <span class="o">...</span> <span class="mf">0.29191507</span> <span class="mf">0.29968456</span> <span class="mf">0.29075691</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.68022984</span> <span class="mf">0.68454348</span> <span class="mf">0.66431651</span> <span class="o">...</span> <span class="mf">0.67952715</span> <span class="mf">0.6805653</span>  <span class="mf">0.66243178</span><span class="p">]]</span>
</pre></div>
</div>
</div>
<div class="section" id="reconstruct-error">
<span id="reconstruct-error"></span><h5>Reconstruct error<a class="headerlink" href="#reconstruct-error" title="Permalink to this headline">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="p">[</span> <span class="mf">0.11668085</span> <span class="mf">0.07513545</span> <span class="mf">0.091044</span>  <span class="o">...</span><span class="p">,</span>  <span class="mf">0.0719339</span>  <span class="mf">0.07976882</span> <span class="mf">0.09121697</span><span class="p">]</span>
</pre></div>
</div>
<p><a name="usecase_building_the_rtrbm_for_recursive_learning"></a></p>
</div>
</div>
</div>
</div>
<div class="section" id="usecase-building-the-rtrbm-for-recursive-learning">
<span id="usecase-building-the-rtrbm-for-recursive-learning"></span><h2>Usecase: Building the RTRBM for recursive learning.<a class="headerlink" href="#usecase-building-the-rtrbm-for-recursive-learning" title="Permalink to this headline">¶</a></h2>
<p>Import Python and Cython modules.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Logistic Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.logistic_function</span> <span class="kn">import</span> <span class="n">LogisticFunction</span>
<span class="c1"># Tanh Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.tanh_function</span> <span class="kn">import</span> <span class="n">TanhFunction</span>
<span class="c1"># Stochastic Gradient Descent(SGD) as optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="c1"># The `Client` in Builder Pattern for building RTRBM.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.recurrent_temporal_rbm</span> <span class="kn">import</span> <span class="n">RecurrentTemporalRBM</span>
</pre></div>
</div>
<p>Instantiate objects and execute learning.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building RTRBM.</span>
<span class="n">rt_rbm</span> <span class="o">=</span> <span class="n">RecurrentTemporalRBM</span><span class="p">(</span>
    <span class="c1"># The number of units in visible layer.</span>
    <span class="n">visible_num</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The number of units in hidden layer.</span>
    <span class="n">hidden_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># The activation function in visible layer.</span>
    <span class="n">visible_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in hidden layer.</span>
    <span class="n">hidden_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in RNN layer.</span>
    <span class="n">rnn_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># is-a `OptParams`.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">SGD</span><span class="p">(),</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="section" id="learning">
<span id="learning"></span><h3>Learning.<a class="headerlink" href="#learning" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code> has a <code class="docutils literal notranslate"><span class="pre">learn</span></code> method, to execute learning observed data points. This method can receive a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of observed data points, which is a rank-3 array-like or sparse matrix of shape: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), as the first argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Learning.</span>
<span class="n">rt_rbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="c1"># The `np.ndarray` of observed data points.</span>
    <span class="n">observed_arr</span><span class="p">,</span>
    <span class="c1"># Training count.</span>
    <span class="n">training_count</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> 
    <span class="c1"># Batch size.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="inferencing">
<span id="inferencing"></span><h3>Inferencing.<a class="headerlink" href="#inferencing" title="Permalink to this headline">¶</a></h3>
<p>After learning, the <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code> provides a function of <code class="docutils literal notranslate"><span class="pre">inference</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Execute recursive learning.</span>
<span class="n">inferenced_arr</span> <span class="o">=</span> <span class="n">rt_rbm</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span>
    <span class="n">test_arr</span><span class="p">,</span>
    <span class="n">training_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
    <span class="n">r_batch_size</span><span class="o">=-</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">observed_arr</span></code>. Returned value <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> is generated by input parameter <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and can be considered as a feature expression of <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> based on the distribution of <code class="docutils literal notranslate"><span class="pre">observed_arr</span></code>. In other words, the features of <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> is a summary of time series information in <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and then the shape is rank-2 array-like or sparse matrix: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>).</p>
</div>
<div class="section" id="feature-points">
<span id="id1"></span><h3>Feature points.<a class="headerlink" href="#feature-points" title="Permalink to this headline">¶</a></h3>
<p>On the other hand, the <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code> has a <code class="docutils literal notranslate"><span class="pre">rbm</span></code> which also stores the feature points in hidden layers. To extract this embedded data, call the method as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">feature_points_arr</span> <span class="o">=</span> <span class="n">rt_rbm</span><span class="o">.</span><span class="n">rbm</span><span class="o">.</span><span class="n">get_feature_points</span><span class="p">()</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">feature_points_arr</span></code> is rank-2 array-like or sparse matrix: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">units</span> <span class="pre">in</span> <span class="pre">hidden</span> <span class="pre">layers</span></code>). So this matrix also means time series data embedded as manifolds.</p>
</div>
<div class="section" id="reconstructed-data">
<span id="reconstructed-data"></span><h3>Reconstructed data.<a class="headerlink" href="#reconstructed-data" title="Permalink to this headline">¶</a></h3>
<p>Although RTRBM itself is not an Auto-Encoder, it can be described as a reconstruction model. In this library, this model has an input reconstruction function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_arr</span> <span class="o">=</span> <span class="n">rt_rbm</span><span class="o">.</span><span class="n">rbm</span><span class="o">.</span><span class="n">get_reconstructed_arr</span><span class="p">()</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">reconstructed_arr</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">observed_arr</span></code>.</p>
<p>If you want to know how to measure its reconstruction errors, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_rt_rbm.ipynb">demo/demo_rt_rbm.ipynb</a>.</p>
</div>
<div class="section" id="save-pre-learned-parameters">
<span id="id2"></span><h3>Save pre-learned parameters.<a class="headerlink" href="#save-pre-learned-parameters" title="Permalink to this headline">¶</a></h3>
<p>The object <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code>, has the method <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code>, to store the pre-learned parameters in a compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> file.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rt_rbm</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span><span class="s2">&quot;/var/tmp/demo_rtrbm.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transfer-learning-in-rtrbm">
<span id="transfer-learning-in-rtrbm"></span><h3>Transfer learning in RTRBM.<a class="headerlink" href="#transfer-learning-in-rtrbm" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code> can be given <code class="docutils literal notranslate"><span class="pre">pre_learned_path_list</span></code> which is a <code class="docutils literal notranslate"><span class="pre">str</span></code> of file path that stores pre-learned parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building RTRBM.</span>
<span class="n">rt_rbm</span> <span class="o">=</span> <span class="n">RecurrentTemporalRBM</span><span class="p">(</span>
    <span class="c1"># The number of units in visible layer.</span>
    <span class="n">visible_num</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The number of units in hidden layer.</span>
    <span class="n">hidden_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># The activation function in visible layer.</span>
    <span class="n">visible_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in hidden layer.</span>
    <span class="n">hidden_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in RNN layer.</span>
    <span class="n">rnn_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># is-a `OptParams`.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">SGD</span><span class="p">(),</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># File path that stores pre-learned parameters.</span>
    <span class="n">pre_learned_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/demo_rtrbm.npz&quot;</span>
<span class="p">)</span>

<span class="c1"># Learning.</span>
<span class="n">rt_rbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="c1"># The `np.ndarray` of observed data points.</span>
    <span class="n">observed_arr</span><span class="p">,</span>
    <span class="c1"># Training count.</span>
    <span class="n">training_count</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> 
    <span class="c1"># Batch size.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usecase-building-the-rnn-rbm-for-recursive-learning">
<span id="usecase-building-the-rnn-rbm-for-recursive-learning"></span><h2>Usecase: Building the RNN-RBM for recursive learning.<a class="headerlink" href="#usecase-building-the-rnn-rbm-for-recursive-learning" title="Permalink to this headline">¶</a></h2>
<p>Import not <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code> but <code class="docutils literal notranslate"><span class="pre">RNNRBM</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building RNN-RBM.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.recurrenttemporalrbm.rnn_rbm</span> <span class="kn">import</span> <span class="n">RNNRBM</span>
</pre></div>
</div>
<p>Instantiate objects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building RNN-RBM.</span>
<span class="n">rt_rbm</span> <span class="o">=</span> <span class="n">RNNRBM</span><span class="p">(</span>
    <span class="c1"># The number of units in visible layer.</span>
    <span class="n">visible_num</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The number of units in hidden layer.</span>
    <span class="n">hidden_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># The activation function in visible layer.</span>
    <span class="n">visible_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in hidden layer.</span>
    <span class="n">hidden_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in RNN layer.</span>
    <span class="n">rnn_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># is-a `OptParams`.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">SGD</span><span class="p">(),</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The function of learning, inferencing, saving pre-learned parameters, and transfer learning are equivalent to <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code> of RTRBM. See <a href="#usecase_building_the_rtrbm_for_recursive_learning">Usecase: Building the RTRBM for recursive learning.</a>.</p>
<p>If you want to know how to measure its reconstruction errors, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_rnn_rbm.ipynb">demo/demo_rnn_rbm.ipynb</a>.</p>
</div>
<div class="section" id="usecase-building-the-lstm-rtrbm-for-recursive-learning">
<span id="usecase-building-the-lstm-rtrbm-for-recursive-learning"></span><h2>Usecase: Building the LSTM-RTRBM for recursive learning.<a class="headerlink" href="#usecase-building-the-lstm-rtrbm-for-recursive-learning" title="Permalink to this headline">¶</a></h2>
<p>Import not <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code> but <code class="docutils literal notranslate"><span class="pre">LSTMRTRBM</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">RecurrentTemporalRBM</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building LSTM-RTRBM.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.recurrenttemporalrbm.lstm_rt_rbm</span> <span class="kn">import</span> <span class="n">LSTMRTRBM</span>
</pre></div>
</div>
<p>Instantiate objects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern for building RNN-RBM.</span>
<span class="n">rt_rbm</span> <span class="o">=</span> <span class="n">LSTMRTRBM</span><span class="p">(</span>
    <span class="c1"># The number of units in visible layer.</span>
    <span class="n">visible_num</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The number of units in hidden layer.</span>
    <span class="n">hidden_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># The activation function in visible layer.</span>
    <span class="n">visible_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in hidden layer.</span>
    <span class="n">hidden_activating_function</span><span class="o">=</span><span class="n">TanhFunction</span><span class="p">(),</span>
    <span class="c1"># The activation function in RNN layer.</span>
    <span class="n">rnn_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># is-a `OptParams`.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">SGD</span><span class="p">(),</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The function of learning, inferencing, saving pre-learned parameters, and transfer learning are equivalent to <code class="docutils literal notranslate"><span class="pre">rt_rbm</span></code> of RTRBM. See <a href="#usecase_building_the_rtrbm_for_recursive_learning">Usecase: Building the RTRBM for recursive learning.</a>.</p>
<p>If you want to know how to measure its reconstruction errors, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_lstm_rt_rbm.ipynb">demo/demo_lstm_rt_rbm.ipynb</a>.</p>
</div>
<div class="section" id="usecase-image-segmentation-by-shape-bm">
<span id="usecase-image-segmentation-by-shape-bm"></span><h2>Usecase: Image segmentation by Shape-BM.<a class="headerlink" href="#usecase-image-segmentation-by-shape-bm" title="Permalink to this headline">¶</a></h2>
<p>First, acquire image data and binarize it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;horse099.jpg&quot;</span><span class="p">)</span>
<span class="n">img</span>
</pre></div>
</div>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/horse099.jpg" /></p>
<p>If you think the size of your image datasets may be large, resize it to an arbitrary size.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>Convert RGB images to binary images.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">img_bin</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
<span class="n">img_bin</span>
</pre></div>
</div>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/horse099_binary.png" /></p>
<p>Set up hyperparameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filter_size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">overlap_n</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.01</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filter_size</span></code> is the ‘filter’ size. This value must be more than <code class="docutils literal notranslate"><span class="pre">4</span></code>. And <code class="docutils literal notranslate"><span class="pre">overlap_n</span></code> is hyperparameter specific to Shape-BM. In the visible layer, this model has so-called local receptive fields by connecting each first hidden unit only to a subset of the visible units, corresponding to one of four square patches. Each patch overlaps its neighbor by <code class="docutils literal notranslate"><span class="pre">overlap_n</span></code> pixels (Eslami, S. A., et al, 2014).</p>
<p><strong>Please note</strong> that the recommended ratio of <code class="docutils literal notranslate"><span class="pre">filter_size</span></code> and <code class="docutils literal notranslate"><span class="pre">overlap_n</span></code> is 5:4. It is not a constraint demanded by pure theory of Shape Boltzmann Machine itself but is a kind of limitation to simplify design and implementation in this library.</p>
<p>And import Python and Cython modules.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The `Client` in Builder Pattern</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.deepboltzmannmachine.shape_boltzmann_machine</span> <span class="kn">import</span> <span class="n">ShapeBoltzmannMachine</span>
<span class="c1"># The `Concrete Builder` in Builder Pattern.</span>
<span class="kn">from</span> <span class="nn">pydbm.dbm.builders.dbm_multi_layer_builder</span> <span class="kn">import</span> <span class="n">DBMMultiLayerBuilder</span>
</pre></div>
</div>
<p>Instantiate objects and call the method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dbm</span> <span class="o">=</span> <span class="n">ShapeBoltzmannMachine</span><span class="p">(</span>
    <span class="n">DBMMultiLayerBuilder</span><span class="p">(),</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
    <span class="n">overlap_n</span><span class="o">=</span><span class="n">overlap_n</span><span class="p">,</span>
    <span class="n">filter_size</span><span class="o">=</span><span class="n">filter_size</span>
<span class="p">)</span>

<span class="n">img_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img_bin</span><span class="p">)</span>
<span class="n">img_arr</span> <span class="o">=</span> <span class="n">img_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="c1"># Execute learning.</span>
<span class="n">dbm</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="c1"># `np.ndarray` of image data.</span>
    <span class="n">img_arr</span><span class="p">,</span>
    <span class="c1"># If approximation is the Contrastive Divergence, this parameter is `k` in CD method.</span>
    <span class="n">training_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="c1"># Batch size in mini-batch training.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="c1"># if `r_batch_size` &gt; 0, the function of `dbm.learn` is a kind of reccursive learning.</span>
    <span class="n">r_batch_size</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="c1"># Learning with the stochastic gradient descent(SGD) or not.</span>
    <span class="n">sgd_flag</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Extract <code class="docutils literal notranslate"><span class="pre">dbm.visible_points_arr</span></code> as the observed data points in visible layer. This <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> is segmented image data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inferenced_data_arr</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">visible_points_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">inferenced_data_arr</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="n">inferenced_data_arr</span>
<span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">inferenced_data_arr</span><span class="p">))</span>
</pre></div>
</div>
<p><img src="https://storage.googleapis.com/accel-brain-code/Deep-Learning-by-means-of-Design-Pattern/img/reconstructed_09.png" /></p>
<div class="section" id="save-pre-learned-parameters-and-transfer-learning-in-shape-boltzmann-machine">
<span id="save-pre-learned-parameters-and-transfer-learning-in-shape-boltzmann-machine"></span><h3>Save pre-learned parameters and transfer learning in Shape Boltzmann Machine.<a class="headerlink" href="#save-pre-learned-parameters-and-transfer-learning-in-shape-boltzmann-machine" title="Permalink to this headline">¶</a></h3>
<p>In transfer learning problem setting, <code class="docutils literal notranslate"><span class="pre">ShapeBoltzmannMachine</span></code> is functionally equivalent to <code class="docutils literal notranslate"><span class="pre">StackedAutoEncoder</span></code>. See <a href="#usecase_extracting_all_feature_points_for_dimensions_reduction_or_pre_learning">Usecase: Extracting all feature points for dimensions reduction(or pre-learning)</a>.</p>
</div>
</div>
<div class="section" id="usecase-casual-use-by-facade-for-building-encoder-decoder-based-on-lstm">
<span id="usecase-casual-use-by-facade-for-building-encoder-decoder-based-on-lstm"></span><h2>Usecase: Casual use by facade for building Encoder/Decoder based on LSTM.<a class="headerlink" href="#usecase-casual-use-by-facade-for-building-encoder-decoder-based-on-lstm" title="Permalink to this headline">¶</a></h2>
<p>Import <code class="docutils literal notranslate"><span class="pre">facade</span></code> module for building Encoder/Decoder based on LSTM.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.rnn.facade_encoder_decoder</span> <span class="kn">import</span> <span class="n">FacadeEncoderDecoder</span>
</pre></div>
</div>
<p>If you want to use an Attention mechanism, import <code class="docutils literal notranslate"><span class="pre">FacadeAttentionEncoderDecoder</span></code> instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.rnn.facade_attention_encoder_decoder</span> <span class="kn">import</span> <span class="n">FacadeAttentionEncoderDecoder</span> <span class="k">as</span> <span class="n">FacadeEncoderDecoder</span>
</pre></div>
</div>
<p>Instantiate object and call the method to learn observed data points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `Facade` for casual user of Encoder/Decoder based on LSTM networks.</span>
<span class="n">facade_encoder_decoder</span> <span class="o">=</span> <span class="n">FacadeEncoderDecoder</span><span class="p">(</span>
    <span class="c1"># The number of units in input layers.</span>
    <span class="n">input_neuron_count</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The length of sequences.</span>
    <span class="c1"># This means refereed maxinum step `t` in feedforward.</span>
    <span class="n">seq_len</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># Refereed maxinum step `t` in BPTT. If `0`, this class referes all past data in BPTT.</span>
    <span class="n">bptt_tau</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># Verbose mode or not. If `True`, this class sets the logger level as `DEBUG`.</span>
    <span class="n">verbose_flag</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Execute learning.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">facade_encoder_decoder</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="n">observed_arr</span><span class="o">=</span><span class="n">observed_arr</span><span class="p">,</span>
    <span class="n">target_arr</span><span class="o">=</span><span class="n">observed_arr</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This method can receive a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of observed data points, which is a rank-3 array-like or sparse matrix of shape: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), as the first and second argument. If the value of this second argument is not equivalent to the first argument and the shape is (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), in other words, the rank is 2, the function of <code class="docutils literal notranslate"><span class="pre">encoder_decoder_controller</span></code> corresponds to a kind of Regression model.</p>
<p>After learning, the <code class="docutils literal notranslate"><span class="pre">facade_encoder_decoder</span></code> provides a function of <code class="docutils literal notranslate"><span class="pre">inference</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Execute recursive learning.</span>
<span class="n">inferenced_arr</span> <span class="o">=</span> <span class="n">facade_encoder_decoder</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">test_arr</span><span class="p">)</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> are equivalent to <code class="docutils literal notranslate"><span class="pre">observed_arr</span></code>. Returned value <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> is generated by input parameter <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and can be considered as a decoded data points based on encoded <code class="docutils literal notranslate"><span class="pre">test_arr</span></code>.</p>
<p>On the other hand, the <code class="docutils literal notranslate"><span class="pre">facade_encoder_decoder</span></code> also stores the feature points in hidden layers. To extract this embedded data, call the method as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">feature_points_arr</span> <span class="o">=</span> <span class="n">facade_encoder_decoder</span><span class="o">.</span><span class="n">get_feature_points</span><span class="p">()</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">feature_points_arr</span></code> is rank-2 array-like or sparse matrix: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">units</span> <span class="pre">in</span> <span class="pre">hidden</span> <span class="pre">layers</span></code>). So this matrix also means time series data embedded as manifolds.</p>
<p>You can check the reconstruction error rate. Call <code class="docutils literal notranslate"><span class="pre">get_reconstruct_error</span></code> method as follow.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reconstruct_error_arr</span> <span class="o">=</span> <span class="n">facade_encoder_decoder</span><span class="o">.</span><span class="n">get_reconstruction_error</span><span class="p">()</span>
</pre></div>
</div>
<p>If you want to know how to minimize the reconstructed error, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb">demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb</a>.</p>
<div class="section" id="save-pre-learned-parameters">
<span id="id3"></span><h3>Save pre-learned parameters.<a class="headerlink" href="#save-pre-learned-parameters" title="Permalink to this headline">¶</a></h3>
<p>The object <code class="docutils literal notranslate"><span class="pre">facade_encoder_decoder</span></code> has the method <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code>, to store the pre-learned parameters in compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> files.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">facade_encoder_decoder</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span>
    <span class="c1"># File path that stores Encoder&#39;s parameters.</span>
    <span class="n">encoder_file_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/encoder.npz&quot;</span><span class="p">,</span>
    <span class="c1"># File path that stores Decoder&#39;s parameters.</span>
    <span class="n">decoder_file_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/decoder.npz&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transfer-learning-in-encoder-decoder-based-on-lstm">
<span id="transfer-learning-in-encoder-decoder-based-on-lstm"></span><h3>Transfer learning in Encoder/Decoder based on LSTM.<a class="headerlink" href="#transfer-learning-in-encoder-decoder-based-on-lstm" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of <code class="docutils literal notranslate"><span class="pre">FacadeEncoderDecoder</span></code> can be given <code class="docutils literal notranslate"><span class="pre">encoder_pre_learned_file_path</span></code> and <code class="docutils literal notranslate"><span class="pre">decoder_pre_learned_file_path</span></code>, which are <code class="docutils literal notranslate"><span class="pre">str</span></code> of file path that stores Encoder/Decoder’s pre-learned parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">facade_encoder_decoder2</span> <span class="o">=</span> <span class="n">FacadeEncoderDecoder</span><span class="p">(</span>
    <span class="c1"># The number of units in input layers.</span>
    <span class="n">input_neuron_count</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The length of sequences.</span>
    <span class="c1"># This means refereed maxinum step `t` in feedforward.</span>
    <span class="n">seq_len</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># Refereed maxinum step `t` in BPTT. If `0`, this class referes all past data in BPTT.</span>
    <span class="n">bptt_tau</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># File path that stored Encoder&#39;s pre-learned parameters.</span>
    <span class="n">encoder_pre_learned_file_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/encoder.npz&quot;</span><span class="p">,</span>
    <span class="c1"># File path that stored Decoder&#39;s pre-learned parameters.</span>
    <span class="n">decoder_pre_learned_file_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/decoder.npz&quot;</span><span class="p">,</span>
    <span class="c1"># Verbose mode or not. If `True`, this class sets the logger level as `DEBUG`.</span>
    <span class="n">verbose_flag</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>

<span class="n">facade_encoder_decoder2</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span>
    <span class="n">observed_arr</span><span class="o">=</span><span class="n">observed_arr</span><span class="p">,</span>
    <span class="n">target_arr</span><span class="o">=</span><span class="n">observed_arr</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="for-more-detail-settings">
<span id="for-more-detail-settings"></span><h3>For more detail settings.<a class="headerlink" href="#for-more-detail-settings" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> of <code class="docutils literal notranslate"><span class="pre">FacadeEncoderDecoder</span></code> can be given many parameters as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `Facade` for casual user of Encoder/Decoder based on LSTM networks.</span>
<span class="n">facade_encoder_decoder</span> <span class="o">=</span> <span class="n">FacadeEncoderDecoder</span><span class="p">(</span>
    <span class="c1"># The number of units in input layers.</span>
    <span class="n">input_neuron_count</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="c1"># The number of units in hidden layers.</span>
    <span class="n">hidden_neuron_count</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="c1"># Epochs of Mini-batch.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="c1"># Batch size of Mini-batch.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of this value every `attenuate_epoch`.</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of `learning_attenuate_rate` every `attenuate_epoch`.</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="c1"># Activation function in hidden layers.</span>
    <span class="n">hidden_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># Activation function in output layers.</span>
    <span class="n">output_activating_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Optimizer which is-a `OptParams`.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">Adam</span><span class="p">(),</span>
    <span class="c1"># The length of sequences.</span>
    <span class="c1"># This means refereed maxinum step `t` in feedforward.</span>
    <span class="n">seq_len</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="c1"># Refereed maxinum step `t` in Backpropagation Through Time(BPTT).</span>
    <span class="c1"># If `0`, this class referes all past data in BPTT.</span>
    <span class="n">bptt_tau</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the loss or score is not improving by at least tol </span>
    <span class="c1"># for two consecutive iterations, convergence is considered </span>
    <span class="c1"># to be reached and training stops.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="c1"># Tolerance for deviation of loss.</span>
    <span class="n">tld</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Verbose mode or not. If `True`, this class sets the logger level as `DEBUG`.</span>
    <span class="n">verbose_flag</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If you want to not only use casually the model but also hack it, see <a href="#usecase_build_encoder_decoder_based_on_LSTM_as_a_reconstruction_model">Usecase: Build Encoder/Decoder based on LSTM as a reconstruction model.</a>.</p>
<p><a name="usecase_build_encoder_decoder_based_on_LSTM_as_a_reconstruction_model"></a></p>
</div>
</div>
<div class="section" id="usecase-build-encoder-decoder-based-on-lstm-or-convlstm-as-a-reconstruction-model">
<span id="usecase-build-encoder-decoder-based-on-lstm-or-convlstm-as-a-reconstruction-model"></span><h2>Usecase: Build Encoder/Decoder based on LSTM or ConvLSTM as a reconstruction model.<a class="headerlink" href="#usecase-build-encoder-decoder-based-on-lstm-or-convlstm-as-a-reconstruction-model" title="Permalink to this headline">¶</a></h2>
<p>Consider functionally reusability and possibility of flexible design, you should use not <code class="docutils literal notranslate"><span class="pre">FacadeEncoderDecoder</span></code> but <code class="docutils literal notranslate"><span class="pre">EncoderDecoderController</span></code> as follows.</p>
<p>Setup logger for verbose output.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span><span class="p">,</span> <span class="n">StreamHandler</span><span class="p">,</span> <span class="n">NullHandler</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="n">ERROR</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;pydbm&quot;</span><span class="p">)</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
</pre></div>
</div>
<p>Import Python and Cython modules for computation graphs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># LSTM Graph which is-a `Synapse`.</span>
<span class="kn">from</span> <span class="nn">pydbm.synapse.recurrenttemporalgraph.lstm_graph</span> <span class="kn">import</span> <span class="n">LSTMGraph</span> <span class="k">as</span> <span class="n">EncoderGraph</span>
<span class="kn">from</span> <span class="nn">pydbm.synapse.recurrenttemporalgraph.lstm_graph</span> <span class="kn">import</span> <span class="n">LSTMGraph</span> <span class="k">as</span> <span class="n">DecoderGraph</span>
</pre></div>
</div>
<p>If you want to introduce the graph of decoder for building an Attention mechanism as the decoder, import <code class="docutils literal notranslate"><span class="pre">AttentionLSTMGraph</span></code> instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.synapse.recurrenttemporalgraph.lstmgraph.attention_lstm_graph</span> <span class="kn">import</span> <span class="n">AttentionLSTMGraph</span> <span class="k">as</span> <span class="n">DecoderGraph</span>
</pre></div>
</div>
<p>Import Python and Cython modules of activation functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Logistic Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.logistic_function</span> <span class="kn">import</span> <span class="n">LogisticFunction</span>
<span class="c1"># Tanh Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.tanh_function</span> <span class="kn">import</span> <span class="n">TanhFunction</span>
</pre></div>
</div>
<p>Import Python and Cython modules for loss function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Loss function.</span>
<span class="kn">from</span> <span class="nn">pydbm.loss.mean_squared_error</span> <span class="kn">import</span> <span class="n">MeanSquaredError</span>
</pre></div>
</div>
<p>Import Python and Cython modules for optimizer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># SGD as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.sgd</span> <span class="kn">import</span> <span class="n">SGD</span> <span class="k">as</span> <span class="n">EncoderSGD</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.sgd</span> <span class="kn">import</span> <span class="n">SGD</span> <span class="k">as</span> <span class="n">DecoderSGD</span>
</pre></div>
</div>
<p>If you want to use not Stochastic Gradient Descent(SGD) but <strong>Adam</strong> optimizer, import <code class="docutils literal notranslate"><span class="pre">Adam</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Adam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.adam</span> <span class="kn">import</span> <span class="n">Adam</span> <span class="k">as</span> <span class="n">EncoderAdam</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.adam</span> <span class="kn">import</span> <span class="n">Adam</span> <span class="k">as</span> <span class="n">DecoderAdam</span>
</pre></div>
</div>
<p>Futhermore, import class for verification of function approximation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Verification.</span>
<span class="kn">from</span> <span class="nn">pydbm.verification.verificate_function_approximation</span> <span class="kn">import</span> <span class="n">VerificateFunctionApproximation</span>
</pre></div>
</div>
<p>The activation by softmax function can be verificated by <code class="docutils literal notranslate"><span class="pre">VerificateSoftmax</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.verification.verificate_softmax</span> <span class="kn">import</span> <span class="n">VerificateSoftmax</span>
</pre></div>
</div>
<p>And import LSTM Model and Encoder/Decoder schema.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># LSTM model.</span>
<span class="kn">from</span> <span class="nn">pydbm.rnn.lstm_model</span> <span class="kn">import</span> <span class="n">LSTMModel</span> <span class="k">as</span> <span class="n">Encoder</span>
<span class="kn">from</span> <span class="nn">pydbm.rnn.lstm_model</span> <span class="kn">import</span> <span class="n">LSTMModel</span> <span class="k">as</span> <span class="n">Decoder</span>

<span class="c1"># Encoder/Decoder</span>
<span class="kn">from</span> <span class="nn">pydbm.rnn.encoder_decoder_controller</span> <span class="kn">import</span> <span class="n">EncoderDecoderController</span>
</pre></div>
</div>
<p>If you want to build an Attention mechanism as the decoder, import <code class="docutils literal notranslate"><span class="pre">AttentionLSTMModel</span></code> instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.rnn.lstmmodel.attention_lstm_model</span> <span class="kn">import</span> <span class="n">AttentionLSTMModel</span> <span class="k">as</span> <span class="n">Decoder</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">Encoder</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Init.</span>
<span class="n">encoder_graph</span> <span class="o">=</span> <span class="n">EncoderGraph</span><span class="p">()</span>

<span class="c1"># Activation function in LSTM.</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">observed_activating_function</span> <span class="o">=</span> <span class="n">TanhFunction</span><span class="p">()</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">input_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">forget_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">output_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">hidden_activating_function</span> <span class="o">=</span> <span class="n">TanhFunction</span><span class="p">()</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">output_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>

<span class="c1"># Initialization strategy.</span>
<span class="c1"># This method initialize each weight matrices and biases in Gaussian distribution: `np.random.normal(size=hoge) * 0.01`.</span>
<span class="n">encoder_graph</span><span class="o">.</span><span class="n">create_rnn_cells</span><span class="p">(</span>
    <span class="n">input_neuron_count</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">hidden_neuron_count</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">output_neuron_count</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="c1"># Optimizer for Encoder.</span>
<span class="n">encoder_opt_params</span> <span class="o">=</span> <span class="n">EncoderAdam</span><span class="p">()</span>
<span class="n">encoder_opt_params</span><span class="o">.</span><span class="n">weight_limit</span> <span class="o">=</span> <span class="mf">1e+03</span>
<span class="n">encoder_opt_params</span><span class="o">.</span><span class="n">dropout_rate</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">encoder</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">(</span>
    <span class="c1"># Delegate `graph` to `LSTMModel`.</span>
    <span class="n">graph</span><span class="o">=</span><span class="n">encoder_graph</span><span class="p">,</span>
    <span class="c1"># Refereed maxinum step `t` in BPTT. If `0`, this class referes all past data in BPTT.</span>
    <span class="n">bptt_tau</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Optimizer.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">encoder_opt_params</span><span class="p">,</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the loss or score is not improving by at least tol </span>
    <span class="c1"># for two consecutive iterations, convergence is considered </span>
    <span class="c1"># to be reached and training stops.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">Decoder</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Init.</span>
<span class="n">decoder_graph</span> <span class="o">=</span> <span class="n">DecoderGraph</span><span class="p">()</span>

<span class="c1"># Activation function in LSTM.</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">observed_activating_function</span> <span class="o">=</span> <span class="n">TanhFunction</span><span class="p">()</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">input_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">forget_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">output_gate_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">hidden_activating_function</span> <span class="o">=</span> <span class="n">TanhFunction</span><span class="p">()</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">output_activating_function</span> <span class="o">=</span> <span class="n">LogisticFunction</span><span class="p">()</span>

<span class="c1"># Initialization strategy.</span>
<span class="c1"># This method initialize each weight matrices and biases in Gaussian distribution: `np.random.normal(size=hoge) * 0.01`.</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">create_rnn_cells</span><span class="p">(</span>
    <span class="n">input_neuron_count</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">hidden_neuron_count</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">output_neuron_count</span><span class="o">=</span><span class="n">observed_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Optimizer for Decoder.</span>
<span class="n">decoder_opt_params</span> <span class="o">=</span> <span class="n">DecoderAdam</span><span class="p">()</span>
<span class="n">decoder_opt_params</span><span class="o">.</span><span class="n">weight_limit</span> <span class="o">=</span> <span class="mf">1e+03</span>
<span class="n">decoder_opt_params</span><span class="o">.</span><span class="n">dropout_rate</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">decoder</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span>
    <span class="c1"># Delegate `graph` to `LSTMModel`.</span>
    <span class="n">graph</span><span class="o">=</span><span class="n">decoder_graph</span><span class="p">,</span>
    <span class="c1"># The length of sequences.</span>
    <span class="n">seq_len</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="c1"># Refereed maxinum step `t` in BPTT. If `0`, this class referes all past data in BPTT.</span>
    <span class="n">bptt_tau</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Optimizer.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">decoder_opt_params</span><span class="p">,</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the loss or score is not improving by at least tol </span>
    <span class="c1"># for two consecutive iterations, convergence is considered </span>
    <span class="c1"># to be reached and training stops.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">EncoderDecoderController</span></code> and delegate <code class="docutils literal notranslate"><span class="pre">encoder</span></code> and <code class="docutils literal notranslate"><span class="pre">decoder</span></code> to this object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">encoder_decoder_controller</span> <span class="o">=</span> <span class="n">EncoderDecoderController</span><span class="p">(</span>
    <span class="c1"># is-a LSTM model.</span>
    <span class="n">encoder</span><span class="o">=</span><span class="n">encoder</span><span class="p">,</span>
    <span class="c1"># is-a LSTM model.</span>
    <span class="n">decoder</span><span class="o">=</span><span class="n">decoder</span><span class="p">,</span>
    <span class="c1"># The number of epochs in mini-batch training.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="c1"># The batch size.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of this value every `attenuate_epoch`.</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of `learning_attenuate_rate` every `attenuate_epoch`.</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the loss or score is not improving by at least tol </span>
    <span class="c1"># for two consecutive iterations, convergence is considered </span>
    <span class="c1"># to be reached and training stops.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If you want to use ConvLSTM as <code class="docutils literal notranslate"><span class="pre">encoder</span></code> and <code class="docutils literal notranslate"><span class="pre">decoder</span></code>, instantiate <code class="docutils literal notranslate"><span class="pre">ConvLSTMModel</span></code> which is-a <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code> and is-a <code class="docutils literal notranslate"><span class="pre">ReconstructableModel</span></code>. See my jupyter notebook for details: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_conv_lstm.ipynb">demo/demo_conv_lstm.ipynb</a>.</p>
<p>In any case, let’s execute learning after instantiation is complete.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Learning.</span>
<span class="n">encoder_decoder_controller</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="n">observed_arr</span><span class="p">,</span> <span class="n">observed_arr</span><span class="p">)</span>
</pre></div>
</div>
<p>If you delegated <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code>s as <code class="docutils literal notranslate"><span class="pre">encoder</span></code> and <code class="docutils literal notranslate"><span class="pre">decoder</span></code>, this method can receive a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of observed data points, which is a <strong>rank-3 array-like or sparse matrix</strong> of shape: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), as the first and second argument. If the value of this second argument is not equivalent to the first argument and the shape is (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), in other words, the rank is <strong>2</strong>, the function of <code class="docutils literal notranslate"><span class="pre">encoder_decoder_controller</span></code> corresponds to a kind of Regression model.</p>
<p>On the other hand, if you delegated <code class="docutils literal notranslate"><span class="pre">ConvLSTMModel</span></code>s as <code class="docutils literal notranslate"><span class="pre">encoder</span></code> and <code class="docutils literal notranslate"><span class="pre">decoder</span></code>, the rank of matrix is <strong>5</strong>. The shape is:(<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">Channel</span></code>, <code class="docutils literal notranslate"><span class="pre">Height</span> <span class="pre">of</span> <span class="pre">images</span></code>, <code class="docutils literal notranslate"><span class="pre">Width</span> <span class="pre">of</span> <span class="pre">images</span></code>).</p>
<p>After learning, the <code class="docutils literal notranslate"><span class="pre">encoder_decoder_controller</span></code> provides a function of <code class="docutils literal notranslate"><span class="pre">inference</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Execute recursive learning.</span>
<span class="n">inferenced_arr</span> <span class="o">=</span> <span class="n">encoder_decoder_controller</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">test_arr</span><span class="p">)</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> are equivalent to <code class="docutils literal notranslate"><span class="pre">observed_arr</span></code>. Returned value <code class="docutils literal notranslate"><span class="pre">inferenced_arr</span></code> is generated by input parameter <code class="docutils literal notranslate"><span class="pre">test_arr</span></code> and can be considered as a decoded data points based on encoded <code class="docutils literal notranslate"><span class="pre">test_arr</span></code>.</p>
<p>On the other hand, the <code class="docutils literal notranslate"><span class="pre">encoder_decoder_controller</span></code> also stores the feature points in hidden layers. To extract this embedded data, call the method as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">feature_points_arr</span> <span class="o">=</span> <span class="n">encoder_decoder_controller</span><span class="o">.</span><span class="n">get_feature_points</span><span class="p">()</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">LSTMModel</span></code>s are delegated, the shape of <code class="docutils literal notranslate"><span class="pre">feature_points_arr</span></code> is <strong>rank-3 array-like or sparse matrix</strong>: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">units</span> <span class="pre">in</span> <span class="pre">hidden</span> <span class="pre">layers</span></code>). On the other hand, if <code class="docutils literal notranslate"><span class="pre">ConvLSTMModel</span></code>s are delegated, the shape of <code class="docutils literal notranslate"><span class="pre">feature_points_arr</span></code> is <strong>rank-5 array-like or sparse matrix</strong>:(<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">Channel</span></code>, <code class="docutils literal notranslate"><span class="pre">Height</span> <span class="pre">of</span> <span class="pre">images</span></code>, <code class="docutils literal notranslate"><span class="pre">Width</span> <span class="pre">of</span> <span class="pre">images</span></code>). So the matrices also mean time series data embedded as manifolds in the hidden layers.</p>
<p>You can check the reconstruction error rate. Call <code class="docutils literal notranslate"><span class="pre">get_reconstruct_error</span></code> method as follow.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reconstruct_error_arr</span> <span class="o">=</span> <span class="n">encoder_decoder_controller</span><span class="o">.</span><span class="n">get_reconstruction_error</span><span class="p">()</span>
</pre></div>
</div>
<p>If you want to know how to minimize the reconstructed error, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb">demo/demo_sine_wave_prediction_by_LSTM_encoder_decoder.ipynb</a>.</p>
<p><a name="build_convolutional_auto_encoder"></a></p>
</div>
<div class="section" id="usecase-build-convolutional-auto-encoder">
<span id="usecase-build-convolutional-auto-encoder"></span><h2>Usecase: Build Convolutional Auto-Encoder.<a class="headerlink" href="#usecase-build-convolutional-auto-encoder" title="Permalink to this headline">¶</a></h2>
<p>Setup logger for verbose output and import Python and Cython modules in the same manner as <a href="#usecase_build_encoder_decoder_based_on_LSTM_as_a_reconstruction_model">Usecase: Build Encoder/Decoder based on LSTM as a reconstruction model</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span><span class="p">,</span> <span class="n">StreamHandler</span><span class="p">,</span> <span class="n">NullHandler</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="n">ERROR</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;pydbm&quot;</span><span class="p">)</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

<span class="c1"># ReLu Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.relu_function</span> <span class="kn">import</span> <span class="n">ReLuFunction</span>
<span class="c1"># Tanh Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.tanh_function</span> <span class="kn">import</span> <span class="n">TanhFunction</span>
<span class="c1"># Logistic Function as activation function.</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.logistic_function</span> <span class="kn">import</span> <span class="n">LogisticFunction</span>

<span class="c1"># Loss function.</span>
<span class="kn">from</span> <span class="nn">pydbm.loss.mean_squared_error</span> <span class="kn">import</span> <span class="n">MeanSquaredError</span>

<span class="c1"># Adam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.adam</span> <span class="kn">import</span> <span class="n">Adam</span>

<span class="c1"># Verification.</span>
<span class="kn">from</span> <span class="nn">pydbm.verification.verificate_function_approximation</span> <span class="kn">import</span> <span class="n">VerificateFunctionApproximation</span>
</pre></div>
</div>
<p>And import Python and Cython modules of the Convolutional Auto-Encoder.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Controller of Convolutional Auto-Encoder</span>
<span class="kn">from</span> <span class="nn">pydbm.cnn.convolutionalneuralnetwork.convolutional_auto_encoder</span> <span class="kn">import</span> <span class="n">ConvolutionalAutoEncoder</span>
<span class="c1"># First convolution layer.</span>
<span class="kn">from</span> <span class="nn">pydbm.cnn.layerablecnn.convolution_layer</span> <span class="kn">import</span> <span class="n">ConvolutionLayer</span> <span class="k">as</span> <span class="n">ConvolutionLayer1</span>
<span class="c1"># Second convolution layer.</span>
<span class="kn">from</span> <span class="nn">pydbm.cnn.layerablecnn.convolution_layer</span> <span class="kn">import</span> <span class="n">ConvolutionLayer</span> <span class="k">as</span> <span class="n">ConvolutionLayer2</span>
<span class="c1"># Computation graph for first convolution layer.</span>
<span class="kn">from</span> <span class="nn">pydbm.synapse.cnn_graph</span> <span class="kn">import</span> <span class="n">CNNGraph</span> <span class="k">as</span> <span class="n">ConvGraph1</span>
<span class="c1"># Computation graph for second convolution layer.</span>
<span class="kn">from</span> <span class="nn">pydbm.synapse.cnn_graph</span> <span class="kn">import</span> <span class="n">CNNGraph</span> <span class="k">as</span> <span class="n">ConvGraph2</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">ConvolutionLayer</span></code>s, delegating <code class="docutils literal notranslate"><span class="pre">CNNGraph</span></code>s respectively.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># First convolution layer.</span>
<span class="n">conv1</span> <span class="o">=</span> <span class="n">ConvolutionLayer1</span><span class="p">(</span>
    <span class="c1"># Computation graph for first convolution layer.</span>
    <span class="n">ConvGraph1</span><span class="p">(</span>
        <span class="c1"># Logistic function as activation function.</span>
        <span class="n">activation_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
        <span class="c1"># The number of `filter`.</span>
        <span class="n">filter_num</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="c1"># Channel.</span>
        <span class="n">channel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1"># The size of kernel.</span>
        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="c1"># The filter scale.</span>
        <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="c1"># The nubmer of stride.</span>
        <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1"># The number of zero-padding.</span>
        <span class="n">pad</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Second convolution layer.</span>
<span class="n">conv2</span> <span class="o">=</span> <span class="n">ConvolutionLayer2</span><span class="p">(</span>
    <span class="c1"># Computation graph for second convolution layer.</span>
    <span class="n">ConvGraph2</span><span class="p">(</span>
        <span class="c1"># Computation graph for second convolution layer.</span>
        <span class="n">activation_function</span><span class="o">=</span><span class="n">LogisticFunction</span><span class="p">(),</span>
        <span class="c1"># The number of `filter`.</span>
        <span class="n">filter_num</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="c1"># Channel.</span>
        <span class="n">channel</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="c1"># The size of kernel.</span>
        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="c1"># The filter scale.</span>
        <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="c1"># The nubmer of stride.</span>
        <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1"># The number of zero-padding.</span>
        <span class="n">pad</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">ConvolutionalAutoEncoder</span></code> and setup parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span> <span class="o">=</span> <span class="n">ConvolutionalAutoEncoder</span><span class="p">(</span>
    <span class="c1"># The `list` of `ConvolutionLayer`.</span>
    <span class="n">layerable_cnn_list</span><span class="o">=</span><span class="p">[</span>
        <span class="n">conv1</span><span class="p">,</span> 
        <span class="n">conv2</span>
    <span class="p">],</span>
    <span class="c1"># The number of epochs in mini-batch training.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="c1"># The batch size.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of this value every `attenuate_epoch`.</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of `learning_attenuate_rate` every `attenuate_epoch`.</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Optimizer.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">Adam</span><span class="p">(),</span>
    <span class="c1"># Verification.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># The rate of dataset for test.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="c1"># When the loss or score is not improving by at least tol </span>
    <span class="c1"># for two consecutive iterations, convergence is considered </span>
    <span class="c1"># to be reached and training stops.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Execute learning.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">img_arr</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">img_arr</span></code> is a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of image data, which is a rank-4 array-like or sparse matrix of shape: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">Channel</span></code>, <code class="docutils literal notranslate"><span class="pre">Height</span> <span class="pre">of</span> <span class="pre">image</span></code>, <code class="docutils literal notranslate"><span class="pre">Width</span> <span class="pre">of</span> <span class="pre">image</span></code>), as the first and second argument. If the value of this second argument is not equivalent to the first argument and the shape is (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">features</span></code>), in other words, the rank is 2, the function of <code class="docutils literal notranslate"><span class="pre">cnn</span></code> corresponds to a kind of Regression model.</p>
<p>After learning, the <code class="docutils literal notranslate"><span class="pre">cnn</span></code> provides a function of <code class="docutils literal notranslate"><span class="pre">inference</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result_arr</span> <span class="o">=</span> <span class="n">cnn</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">test_img_arr</span><span class="p">[:</span><span class="mi">100</span><span class="p">])</span>
</pre></div>
</div>
<p>The shape of <code class="docutils literal notranslate"><span class="pre">test_img_arr</span></code> and <code class="docutils literal notranslate"><span class="pre">result_arr</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">img_arr</span></code>.</p>
<p>If you want to know how to visualize the reconstructed images, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_convolutional_auto_encoder.ipynb">demo/demo_convolutional_auto_encoder.ipynb</a>.</p>
<div class="section" id="save-pre-learned-parameters">
<span id="id4"></span><h3>Save pre-learned parameters.<a class="headerlink" href="#save-pre-learned-parameters" title="Permalink to this headline">¶</a></h3>
<p>The object <code class="docutils literal notranslate"><span class="pre">cnn</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">ConvolutionalNeuralNetwork</span></code>, has the method <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code>, to store the pre-learned parameters in compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> files.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save pre-learned parameters.</span>
<span class="n">cnn</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span>
    <span class="c1"># Path of dir. If `None`, the file is saved in the current directory.</span>
    <span class="n">dir_path</span><span class="o">=</span><span class="s2">&quot;/var/tmp/&quot;</span><span class="p">,</span>
    <span class="c1"># The naming rule of files. If `None`, this value is `cnn`.</span>
    <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;demo_cnn&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transfer-learning-in-convolutional-auto-encoder">
<span id="transfer-learning-in-convolutional-auto-encoder"></span><h3>Transfer learning in Convolutional Auto-Encoder.<a class="headerlink" href="#transfer-learning-in-convolutional-auto-encoder" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> of <code class="docutils literal notranslate"><span class="pre">ConvolutionalAutoEncoder</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">ConvolutionalNeuralNetwork</span></code>, can be given <code class="docutils literal notranslate"><span class="pre">pre_learned_path_list</span></code> which is a <code class="docutils literal notranslate"><span class="pre">list</span></code> of file paths that store pre-learned parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn2</span> <span class="o">=</span> <span class="n">ConvolutionalAutoEncoder</span><span class="p">(</span>
    <span class="n">layerable_cnn_list</span><span class="o">=</span><span class="p">[</span>
        <span class="n">conv1</span><span class="p">,</span> 
        <span class="n">conv2</span>
    <span class="p">],</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">Adam</span><span class="p">(),</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span>
    <span class="n">save_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">pre_learned_path_list</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;pre-learned/demo_cnn_0.npz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pre-learned/demo_cnn_1.npz&quot;</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Execute learning.</span>
<span class="n">cnn2</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">img_arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usecase-build-spatio-temporal-auto-encoder">
<span id="usecase-build-spatio-temporal-auto-encoder"></span><h2>Usecase: Build Spatio-Temporal Auto-Encoder.<a class="headerlink" href="#usecase-build-spatio-temporal-auto-encoder" title="Permalink to this headline">¶</a></h2>
<p>Setup logger for verbose output and import Python and Cython modules in the same manner as <a href="#usecase_build_encoder_decoder_based_on_LSTM_as_a_reconstruction_model">Usecase: Build Encoder/Decoder based on LSTM as a reconstruction model</a>.</p>
<p>Import Python and Cython modules of the Spatio-Temporal Auto-Encoder.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.cnn.spatio_temporal_auto_encoder</span> <span class="kn">import</span> <span class="n">SpatioTemporalAutoEncoder</span>
</pre></div>
</div>
<p>Build Convolutional Auto-Encoder in the same manner as <a href="#build_convolutional_auto_encoder">Usecase: Build Convolutional Auto-Encoder.</a> and build Encoder/Decoder in the same manner as <a href="#usecase_build_encoder_decoder_based_on_LSTM_as_a_reconstruction_model">Usecase: Build Encoder/Decoder based on LSTM as a reconstruction model</a>.</p>
<p>Instantiate <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code> and setup parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span> <span class="o">=</span> <span class="n">SpatioTemporalAutoEncoder</span><span class="p">(</span>
    <span class="c1"># The `list` of `LayerableCNN`.</span>
    <span class="n">layerable_cnn_list</span><span class="o">=</span><span class="p">[</span>
        <span class="n">conv1</span><span class="p">,</span> 
        <span class="n">conv2</span>
    <span class="p">],</span>
    <span class="c1"># is-a `ReconstructableModel`.</span>
    <span class="n">encoder</span><span class="o">=</span><span class="n">encoder</span><span class="p">,</span>
    <span class="c1"># is-a `ReconstructableModel`.</span>
    <span class="n">decoder</span><span class="o">=</span><span class="n">decoder</span><span class="p">,</span>
    <span class="c1"># Epochs of Mini-batch.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># Batch size of Mini-batch.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of this value every `attenuate_epoch`.</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of `learning_attenuate_rate` every `attenuate_epoch`.</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Optimization function.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">Adam</span><span class="p">(),</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Execute learning.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">img_arr</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">img_arr</span></code> is a <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code> of image data, which is a <strong>rank-5</strong> array-like or sparse matrix of shape: (<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">samples</span></code>, <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">one</span> <span class="pre">sequence</span></code>, <code class="docutils literal notranslate"><span class="pre">Channel</span></code>, <code class="docutils literal notranslate"><span class="pre">Height</span> <span class="pre">of</span> <span class="pre">image</span></code>, <code class="docutils literal notranslate"><span class="pre">Width</span> <span class="pre">of</span> <span class="pre">image</span></code>), as the first and second argument.</p>
<p>After learning, the <code class="docutils literal notranslate"><span class="pre">cnn</span></code> provides a function of <code class="docutils literal notranslate"><span class="pre">inference</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result_arr</span> <span class="o">=</span> <span class="n">cnn</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">test_img_arr</span><span class="p">[:</span><span class="mi">100</span><span class="p">])</span>
</pre></div>
</div>
<p>If you want to know how to visualize the reconstructed video images, see my Jupyter notebook: <a class="reference external" href="https://github.com/chimera0/accel-brain-code/blob/master/Deep-Learning-by-means-of-Design-Pattern/demo/demo_spatio_temporal_auto_encoder.ipynb">demo/demo_spatio_temporal_auto_encoder.ipynb</a>.</p>
<div class="section" id="save-pre-learned-parameters">
<span id="id5"></span><h3>Save pre-learned parameters.<a class="headerlink" href="#save-pre-learned-parameters" title="Permalink to this headline">¶</a></h3>
<p>The object <code class="docutils literal notranslate"><span class="pre">cnn</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code>, has the method <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code>, to store the pre-learned parameters in compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> files.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span><span class="s2">&quot;/var/tmp/spae/&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="naming-rule-of-saved-files">
<span id="naming-rule-of-saved-files"></span><h4>Naming rule of saved files.<a class="headerlink" href="#naming-rule-of-saved-files" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">spatio_cnn_X.npz</span></code>: Pre-learned parameters in <code class="docutils literal notranslate"><span class="pre">X</span></code> layer of Convolutional Auto-Encoder.</li>
<li><code class="docutils literal notranslate"><span class="pre">temporal_encoder.npz</span></code>: Pre-learned parameters in the Temporal Encoder.</li>
<li><code class="docutils literal notranslate"><span class="pre">temporal_decoder.npz</span></code>: Pre-learned parameters in the Temporal Decoder.</li>
</ul>
</div>
</div>
<div class="section" id="transfer-learning-in-spatio-temporal-auto-encoder">
<span id="transfer-learning-in-spatio-temporal-auto-encoder"></span><h3>Transfer learning in Spatio-Temporal Auto-Encoder.<a class="headerlink" href="#transfer-learning-in-spatio-temporal-auto-encoder" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code> can be given <code class="docutils literal notranslate"><span class="pre">pre_learned_dir</span></code>, which is-a <code class="docutils literal notranslate"><span class="pre">str</span></code> of directory path that stores pre-learned parameters of the Convolutional Auto-Encoder and the Encoder/Decoder based on LSTM.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn2</span> <span class="o">=</span> <span class="n">SpatioTemporalAutoEncoder</span><span class="p">(</span>
    <span class="c1"># The `list` of `LayerableCNN`.</span>
    <span class="n">layerable_cnn_list</span><span class="o">=</span><span class="p">[</span>
        <span class="n">conv1</span><span class="p">,</span> 
        <span class="n">conv2</span>
    <span class="p">],</span>
    <span class="c1"># is-a `ReconstructableModel`.</span>
    <span class="n">encoder</span><span class="o">=</span><span class="n">encoder</span><span class="p">,</span>
    <span class="c1"># is-a `ReconstructableModel`.</span>
    <span class="n">decoder</span><span class="o">=</span><span class="n">decoder</span><span class="p">,</span>
    <span class="c1"># Epochs of Mini-batch.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># Batch size of Mini-batch.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="c1"># Learning rate.</span>
    <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of this value every `attenuate_epoch`.</span>
    <span class="n">learning_attenuate_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="c1"># Attenuate the `learning_rate` by a factor of `learning_attenuate_rate` every `attenuate_epoch`.</span>
    <span class="n">attenuate_epoch</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="c1"># Loss function.</span>
    <span class="n">computable_loss</span><span class="o">=</span><span class="n">MeanSquaredError</span><span class="p">(),</span>
    <span class="c1"># Optimization function.</span>
    <span class="n">opt_params</span><span class="o">=</span><span class="n">Adam</span><span class="p">(),</span>
    <span class="c1"># Verification function.</span>
    <span class="n">verificatable_result</span><span class="o">=</span><span class="n">VerificateFunctionApproximation</span><span class="p">(),</span>
    <span class="c1"># Size of Test data set. If this value is `0`, the validation will not be executed.</span>
    <span class="n">test_size_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="c1"># Tolerance for the optimization.</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span>
    <span class="c1"># Path to directory that stores pre-learned parameters.</span>
    <span class="n">pre_learned_dir</span><span class="o">=</span><span class="s2">&quot;/var/tmp/spae/&quot;</span>
<span class="p">)</span>

<span class="n">cnn2</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">img_arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usecase-build-optimizer">
<span id="usecase-build-optimizer"></span><h2>Usecase: Build Optimizer.<a class="headerlink" href="#usecase-build-optimizer" title="Permalink to this headline">¶</a></h2>
<p>If you want to use various optimizers other than Stochastic Gradient Descent(SGD), instantiate each class as follows.</p>
<div class="section" id="adaptive-subgradient-methods-adagrad">
<span id="adaptive-subgradient-methods-adagrad"></span><h3>Adaptive subgradient methods(AdaGrad).<a class="headerlink" href="#adaptive-subgradient-methods-adagrad" title="Permalink to this headline">¶</a></h3>
<p>If you want to use Adaptive subgradient methods(AdaGrad) optimizer, import <code class="docutils literal notranslate"><span class="pre">AdaGrad</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># AdaGrad as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.ada_grad</span> <span class="kn">import</span> <span class="n">AdaGrad</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">AdaGrad</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="adaptive-rootmean-square-rmsprop-gradient-decent-algorithm">
<span id="adaptive-rootmean-square-rmsprop-gradient-decent-algorithm"></span><h3>Adaptive RootMean-Square (RMSProp) gradient decent algorithm.<a class="headerlink" href="#adaptive-rootmean-square-rmsprop-gradient-decent-algorithm" title="Permalink to this headline">¶</a></h3>
<p>If you want to use an optimizer of the Adaptive RootMean-Square (RMSProp) gradient decent algorithm, import <code class="docutils literal notranslate"><span class="pre">RMSProp</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># RMSProp as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.rms_prop</span> <span class="kn">import</span> <span class="n">RMSProp</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">RMSProp</span><span class="p">(</span>
    <span class="c1"># Decay rate.</span>
    <span class="n">decay_rate</span><span class="o">=</span><span class="mf">0.99</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="nesterov-s-accelerated-gradient-nag">
<span id="nesterov-s-accelerated-gradient-nag"></span><h3>Nesterov’s Accelerated Gradient(NAG).<a class="headerlink" href="#nesterov-s-accelerated-gradient-nag" title="Permalink to this headline">¶</a></h3>
<p>If you want to use the Nesterov’s Accelerated Gradient(NAG) optimizer, import <code class="docutils literal notranslate"><span class="pre">NAG</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Adam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.nag</span> <span class="kn">import</span> <span class="n">NAG</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">NAG</span><span class="p">(</span>
    <span class="c1"># Momentum.</span>
    <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="adaptive-moment-estimation-adam">
<span id="adaptive-moment-estimation-adam"></span><h3>Adaptive Moment Estimation(Adam).<a class="headerlink" href="#adaptive-moment-estimation-adam" title="Permalink to this headline">¶</a></h3>
<p>If you want to use the Adaptive Moment Estimation(Adam) optimizer, import <code class="docutils literal notranslate"><span class="pre">Adam</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Adam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.adam</span> <span class="kn">import</span> <span class="n">Adam</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span>
    <span class="c1"># BETA 1.</span>
    <span class="n">beta_1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="c1"># BETA 2.</span>
    <span class="n">beta_2</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>
    <span class="c1"># Compute bias-corrected first moment / second raw moment estimate or not.</span>
    <span class="n">bias_corrected_flag</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="nesterov-accelerated-adaptive-moment-estimation-nadam">
<span id="nesterov-accelerated-adaptive-moment-estimation-nadam"></span><h3>Nesterov-accelerated Adaptive Moment Estimation(Nadam).<a class="headerlink" href="#nesterov-accelerated-adaptive-moment-estimation-nadam" title="Permalink to this headline">¶</a></h3>
<p>If you want to use the Nesterov-accelerated Adaptive Moment Estimation(Nadam) optimizer, import <code class="docutils literal notranslate"><span class="pre">Nadam</span></code> and instantiate it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Nadam as a optimizer.</span>
<span class="kn">from</span> <span class="nn">pydbm.optimization.optparams.nadam</span> <span class="kn">import</span> <span class="n">Nadam</span>

<span class="c1"># is-a `OptParams`.</span>
<span class="n">opt_params</span> <span class="o">=</span> <span class="n">Nadam</span><span class="p">(</span>
    <span class="c1"># BETA 1.</span>
    <span class="n">beta_1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="c1"># BETA 2.</span>
    <span class="n">beta_2</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>
    <span class="c1"># Compute bias-corrected first moment / second raw moment estimate or not.</span>
    <span class="n">bias_corrected_flag</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="usecase-tied-weights">
<span id="usecase-tied-weights"></span><h2>Usecase: Tied-weights.<a class="headerlink" href="#usecase-tied-weights" title="Permalink to this headline">¶</a></h2>
<p>An Auto-Encoder is guaranteed to have a well-defined energy function if it has tied weights. It reduces the number of parameters.</p>
<div><blockquote>
"It is interesting to note that for an autoencoder whose weights are not tied, contractive regularization will encourage the vector field to be conservative. The reason is that encouraging the first derivative to be small and the second derivative to be negative will tend to bound the energy surface near the training."
</blockquote>
Kamyshanska, H., & Memisevic, R. (2014). The potential energy of an autoencoder. IEEE transactions on pattern analysis and machine intelligence, 37(6), 1261-1273., p7.
</div><p>In this library, <code class="docutils literal notranslate"><span class="pre">ConvolutionalAutoEncoder</span></code>’s weights are tied in default. But the weight matrixs of <code class="docutils literal notranslate"><span class="pre">SimpleAutoEncoder</span></code> which has two <code class="docutils literal notranslate"><span class="pre">NeuralNetwork</span></code>s are not tied. If you want to tie the weights, set the <code class="docutils literal notranslate"><span class="pre">tied_graph</span></code> as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pydbm.synapse.nn_graph</span> <span class="kn">import</span> <span class="n">NNGraph</span>
<span class="kn">from</span> <span class="nn">pydbm.activation.identity_function</span> <span class="kn">import</span> <span class="n">IdentityFunction</span>

<span class="c1"># Encoder&#39;s graph.</span>
<span class="n">encoder_graph</span> <span class="o">=</span> <span class="n">NNGraph</span><span class="p">(</span>
    <span class="n">activation_function</span><span class="o">=</span><span class="n">IdentityFunction</span><span class="p">(),</span>
    <span class="n">hidden_neuron_count</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">output_neuron_count</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Decoder&#39;s graph.</span>
<span class="n">decoder_graph</span> <span class="o">=</span> <span class="n">NNGraph</span><span class="p">(</span>
    <span class="n">activation_function</span><span class="o">=</span><span class="n">IdentityFunction</span><span class="p">(),</span>
    <span class="n">hidden_neuron_count</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">output_neuron_count</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Set encoder&#39;s graph.</span>
<span class="n">decoder_graph</span><span class="o">.</span><span class="n">tied_graph</span> <span class="o">=</span> <span class="n">encoder_graph</span>
</pre></div>
</div>
</div>
<div class="section" id="usecase-build-and-delegate-image-generator">
<span id="usecase-build-and-delegate-image-generator"></span><h2>Usecase: Build and delegate image generator.<a class="headerlink" href="#usecase-build-and-delegate-image-generator" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ConvolutionalAutoEncoder</span></code> and <code class="docutils literal notranslate"><span class="pre">SpatioTemporalAutoEncoder</span></code>, which are <code class="docutils literal notranslate"><span class="pre">ConvolutionalNeuralNetwork</span></code>s, provide a method <code class="docutils literal notranslate"><span class="pre">learn_generated</span></code> which can be delegated an <code class="docutils literal notranslate"><span class="pre">ImageGenerator</span></code>. <code class="docutils literal notranslate"><span class="pre">ImageGenerator</span></code> is an Iterates to reads batches of images from local directories for mini-batch training.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Image generator for Auto-Encoder or Encoder/Decoder scheme.</span>
<span class="kn">from</span> <span class="nn">pydbm.cnn.featuregenerator.image_generator</span> <span class="kn">import</span> <span class="n">ImageGenerator</span>

<span class="n">feature_generator</span> <span class="o">=</span> <span class="n">ImageGenerator</span><span class="p">(</span>
    <span class="c1"># Epochs of Mini-batch.</span>
    <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="c1"># Batch size of Mini-batch.</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="c1"># Path of directory which stores image files for training.</span>
    <span class="n">training_image_dir</span><span class="o">=</span><span class="s2">&quot;img/training/&quot;</span><span class="p">,</span>
    <span class="c1"># Path of directory which stores image files for test.</span>
    <span class="n">test_image_dir</span><span class="o">=</span><span class="s2">&quot;img/test/&quot;</span><span class="p">,</span>
    <span class="c1"># The length of one sequence.</span>
    <span class="c1"># If `None`, generated `np.ndarray` of images will be rank-4 matrices.</span>
    <span class="n">seq_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="c1"># Gray scale or not.</span>
    <span class="n">gray_scale_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="c1"># Height and width of images. The shape is: Tuple(`width`, `height`).</span>
    <span class="n">wh_size_tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">94</span><span class="p">,</span> <span class="mi">96</span><span class="p">),</span>
    <span class="c1"># Normalization mode. `z_score` or `min_max`.</span>
    <span class="n">norm_mode</span><span class="o">=</span><span class="s2">&quot;z_score&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Delegate <code class="docutils literal notranslate"><span class="pre">feature_generator</span></code> to <code class="docutils literal notranslate"><span class="pre">cnn</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cnn</span><span class="o">.</span><span class="n">learn_generated</span><span class="p">(</span><span class="n">feature_generator</span><span class="p">)</span>
</pre></div>
</div>
<p>Method <code class="docutils literal notranslate"><span class="pre">learn_generated</span></code> is functionally equivalent to method <code class="docutils literal notranslate"><span class="pre">learn</span></code>.</p>
</div>
<div class="section" id="usecase-save-and-load-the-pre-learned-parameters-in-computation-graphs">
<span id="usecase-save-and-load-the-pre-learned-parameters-in-computation-graphs"></span><h2>Usecase: Save and load the pre-learned parameters in computation graphs.<a class="headerlink" href="#usecase-save-and-load-the-pre-learned-parameters-in-computation-graphs" title="Permalink to this headline">¶</a></h2>
<p>For file management of pre-learned parameters in the transfer learning problem setting, each computation graph, which is-a <code class="docutils literal notranslate"><span class="pre">Synapse</span></code>, provides two methods: <code class="docutils literal notranslate"><span class="pre">save_pre_learned_params</span></code> and <code class="docutils literal notranslate"><span class="pre">load_pre_learned_params</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save pre-learned parameters.</span>
<span class="n">synapse</span><span class="o">.</span><span class="n">save_pre_learned_params</span><span class="p">(</span><span class="s2">&quot;/var/tmp/pre_learned.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The function of this method is to store the pre-learned parameters in compressed <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.lib.format.html#module-numpy.lib.format" target="_blank">NPY format</a> files.</p>
<p>And call the method <code class="docutils literal notranslate"><span class="pre">load_pre_learned_params</span></code> to execute transfer learning or re-learn.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load pre-learned parameters.</span>
<span class="n">synapse</span><span class="o">.</span><span class="n">load_pre_learned_params</span><span class="p">(</span><span class="s2">&quot;/var/tmp/pre_learned.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">Synapse</span></code> has sub-classes: <code class="docutils literal notranslate"><span class="pre">CompleteBipartiteGraph</span></code>, <code class="docutils literal notranslate"><span class="pre">LSTMGraph</span></code>, <code class="docutils literal notranslate"><span class="pre">CNNGraph</span></code>, and so on. All computation graphs make it possible to do pre-learning and transfer learning.</p>
</div>
<div class="section" id="references">
<span id="references"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<div class="section" id="deep-boltzmann-machines">
<span id="deep-boltzmann-machines"></span><h3>Deep Boltzmann machines.<a class="headerlink" href="#deep-boltzmann-machines" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Ackley, D. H., Hinton, G. E., &amp; Sejnowski, T. J. (1985). A learning algorithm for Boltzmann machines. Cognitive science, 9(1), 147-169.</li>
<li>Boulanger-Lewandowski, N., Bengio, Y., &amp; Vincent, P. (2012). Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription. arXiv preprint arXiv:1206.6392.</li>
<li>Eslami, S. A., Heess, N., Williams, C. K., &amp; Winn, J. (2014). The shape boltzmann machine: a strong model of object shape. International Journal of Computer Vision, 107(2), 155-176.</li>
<li>Hinton, G. E. (2002). Training products of experts by minimizing contrastive divergence. Neural computation, 14(8), 1771-1800.</li>
<li>Le Roux, N., &amp; Bengio, Y. (2008). Representational power of restricted Boltzmann machines and deep belief networks. Neural computation, 20(6), 1631-1649.</li>
<li>Lyu, Q., Wu, Z., Zhu, J., &amp; Meng, H. (2015, June). Modelling High-Dimensional Sequences with LSTM-RTRBM: Application to Polyphonic Music Generation. In IJCAI (pp. 4138-4139).</li>
<li>Lyu, Q., Wu, Z., &amp; Zhu, J. (2015, October). Polyphonic music modelling with LSTM-RTRBM. In Proceedings of the 23rd ACM international conference on Multimedia (pp. 991-994). ACM.</li>
<li>Salakhutdinov, R., &amp; Hinton, G. E. (2009). Deep boltzmann machines. InInternational conference on artificial intelligence and statistics (pp. 448-455).</li>
<li>Sutskever, I., Hinton, G. E., &amp; Taylor, G. W. (2009). The recurrent temporal restricted boltzmann machine. In Advances in Neural Information Processing Systems (pp. 1601-1608).</li>
</ul>
</div>
<div class="section" id="encoder-decoder-schemes-with-an-attention-mechanism">
<span id="encoder-decoder-schemes-with-an-attention-mechanism"></span><h3>Encoder/Decoder schemes with an Attention mechanism.<a class="headerlink" href="#encoder-decoder-schemes-with-an-attention-mechanism" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Bahdanau, D., Cho, K., &amp; Bengio, Y. (2014). Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473.</li>
<li>Cho, K., Van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., &amp; Bengio, Y. (2014). Learning phrase representations using RNN encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078.</li>
<li>Malhotra, P., Ramakrishnan, A., Anand, G., Vig, L., Agarwal, P., &amp; Shroff, G. (2016). LSTM-based encoder-decoder for multi-sensor anomaly detection. arXiv preprint arXiv:1607.00148.</li>
<li>Xingjian, S. H. I., Chen, Z., Wang, H., Yeung, D. Y., Wong, W. K., &amp; Woo, W. C. (2015). Convolutional LSTM network: A machine learning approach for precipitation nowcasting. In Advances in neural information processing systems (pp. 802-810).</li>
<li>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … &amp; Polosukhin, I. (2017). Attention is all you need. In Advances in Neural Information Processing Systems (pp. 5998-6008).</li>
</ul>
</div>
<div class="section" id="auto-encoders">
<span id="auto-encoders"></span><h3>Auto-Encoders.<a class="headerlink" href="#auto-encoders" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Baccouche, M., Mamalet, F., Wolf, C., Garcia, C., &amp; Baskurt, A. (2012, September). Spatio-Temporal Convolutional Sparse Auto-Encoder for Sequence Classification. In BMVC (pp. 1-12).</li>
<li>Bengio, Y., Yao, L., Alain, G., &amp; Vincent, P. (2013). Generalized denoising auto-encoders as generative models. In Advances in neural information processing systems (pp. 899-907).</li>
<li>Chong, Y. S., &amp; Tay, Y. H. (2017, June). Abnormal event detection in videos using spatiotemporal autoencoder. In International Symposium on Neural Networks (pp. 189-196). Springer, Cham.</li>
<li>Masci, J., Meier, U., Cireşan, D., &amp; Schmidhuber, J. (2011, June). Stacked convolutional auto-encoders for hierarchical feature extraction. In International Conference on Artificial Neural Networks (pp. 52-59). Springer, Berlin, Heidelberg.</li>
<li>Patraucean, V., Handa, A., &amp; Cipolla, R. (2015). Spatio-temporal video autoencoder with differentiable memory. arXiv preprint arXiv:1511.06309.</li>
<li>Rifai, S., Vincent, P., Muller, X., Glorot, X., &amp; Bengio, Y. (2011, June). Contractive auto-encoders: Explicit invariance during feature extraction. In Proceedings of the 28th International Conference on International Conference on Machine Learning (pp. 833-840). Omnipress.</li>
<li>Rifai, S., Mesnil, G., Vincent, P., Muller, X., Bengio, Y., Dauphin, Y., &amp; Glorot, X. (2011, September). Higher order contractive auto-encoder. In Joint European Conference on Machine Learning and Knowledge Discovery in Databases (pp. 645-660). Springer, Berlin, Heidelberg.</li>
<li>Seung, H. S. (1998). Learning continuous attractors in recurrent networks. In Advances in neural information processing systems (pp. 654-660).</li>
<li>Zhao, J., Mathieu, M., &amp; LeCun, Y. (2016). Energy-based generative adversarial network. arXiv preprint arXiv:1609.03126.</li>
</ul>
</div>
<div class="section" id="generative-adversarial-networks-gans">
<span id="generative-adversarial-networks-gans"></span><h3>Generative Adversarial Networks(GANs).<a class="headerlink" href="#generative-adversarial-networks-gans" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … &amp; Bengio, Y. (2014). Generative adversarial nets. In Advances in neural information processing systems (pp. 2672-2680).</li>
<li>Makhzani, A., Shlens, J., Jaitly, N., Goodfellow, I., &amp; Frey, B. (2015). Adversarial autoencoders. arXiv preprint arXiv:1511.05644.</li>
<li>Zhao, J., Mathieu, M., &amp; LeCun, Y. (2016). Energy-based generative adversarial network. arXiv preprint arXiv:1609.03126.</li>
</ul>
</div>
<div class="section" id="unsupervised-supervised-pre-training">
<span id="unsupervised-supervised-pre-training"></span><h3>Unsupervised / Supervised pre-training<a class="headerlink" href="#unsupervised-supervised-pre-training" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Bengio, Y., Lamblin, P., Popovici, D., &amp; Larochelle, H. (2007). Greedy layer-wise training of deep networks. In Advances in neural information processing systems (pp. 153-160).</li>
<li>Erhan, D., Bengio, Y., Courville, A., Manzagol, P. A., Vincent, P., &amp; Bengio, S. (2010). Why does unsupervised pre-training help deep learning?. Journal of Machine Learning Research, 11(Feb), 625-660.</li>
</ul>
</div>
<div class="section" id="representations-learning">
<span id="representations-learning"></span><h3>Representations learning.<a class="headerlink" href="#representations-learning" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Erhan, D., Courville, A., &amp; Bengio, Y. (2010). Understanding representations learned in deep architectures. Department dInformatique et Recherche Operationnelle, University of Montreal, QC, Canada, Tech. Rep, 1355, 1.</li>
<li>Goodfellow, I., Bengio, Y., &amp; Courville, A. (2016). Deep learning (adaptive computation and machine learning series). Adaptive Computation and Machine Learning series, 800.</li>
</ul>
</div>
<div class="section" id="semi-supervised-learning">
<span id="semi-supervised-learning"></span><h3>Semi-supervised learning.<a class="headerlink" href="#semi-supervised-learning" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Ghifary, M., Kleijn, W. B., Zhang, M., Balduzzi, D., &amp; Li, W. (2016, October). Deep reconstruction-classification networks for unsupervised domain adaptation. In European Conference on Computer Vision (pp. 597-613). Springer, Cham.</li>
<li>Rasmus, A., Berglund, M., Honkala, M., Valpola, H., &amp; Raiko, T. (2015). Semi-supervised learning with ladder networks. In Advances in neural information processing systems (pp. 3546-3554).</li>
<li>Valpola, H. (2015). From neural PCA to deep unsupervised learning. In Advances in Independent Component Analysis and Learning Machines (pp. 143-171). Academic Press.</li>
</ul>
</div>
<div class="section" id="deep-embedded-clustering">
<span id="deep-embedded-clustering"></span><h3>Deep Embedded Clustering.<a class="headerlink" href="#deep-embedded-clustering" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Aljalbout, E., Golkov, V., Siddiqui, Y., Strobel, M., &amp; Cremers, D. (2018). Clustering with deep learning: Taxonomy and new methods. arXiv preprint arXiv:1801.07648.</li>
<li>Guo, X., Gao, L., Liu, X., &amp; Yin, J. (2017, June). Improved Deep Embedded Clustering with Local Structure Preservation. In IJCAI (pp. 1753-1759).</li>
<li>Guo, X., Liu, X., Zhu, E., &amp; Yin, J. (2017, November). Deep clustering with convolutional autoencoders. In International Conference on Neural Information Processing (pp. 373-382). Springer, Cham.</li>
<li>Ren, Y., Hu, K., Dai, X., Pan, L., Hoi, S. C., &amp; Xu, Z. (2019). Semi-supervised deep embedded clustering. Neurocomputing, 325, 121-130.</li>
<li>Xie, J., Girshick, R., &amp; Farhadi, A. (2016, June). Unsupervised deep embedding for clustering analysis. In International conference on machine learning (pp. 478-487).</li>
<li>Zhao, J., Mathieu, M., &amp; LeCun, Y. (2016). Energy-based generative adversarial network. arXiv preprint arXiv:1609.03126.</li>
<li>Wagstaff, K., Cardie, C., Rogers, S., &amp; Schrödl, S. (2001, June). Constrained k-means clustering with background knowledge. In Icml (Vol. 1, pp. 577-584).</li>
</ul>
</div>
<div class="section" id="optimizations">
<span id="optimizations"></span><h3>Optimizations.<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Bengio, Y., Boulanger-Lewandowski, N., &amp; Pascanu, R. (2013, May). Advances in optimizing recurrent networks. In 2013 IEEE International Conference on Acoustics, Speech and Signal Processing (pp. 8624-8628). IEEE.</li>
<li>Duchi, J., Hazan, E., &amp; Singer, Y. (2011). Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 12(Jul), 2121-2159.</li>
<li>Dozat, T. (2016). Incorporating nesterov momentum into adam., Workshop track - ICLR 2016.</li>
<li>Kingma, D. P., &amp; Ba, J. (2014). Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.</li>
</ul>
</div>
<div class="section" id="algorithms-arithmetic-and-regularizations">
<span id="algorithms-arithmetic-and-regularizations"></span><h3>Algorithms, Arithmetic, and Regularizations<a class="headerlink" href="#algorithms-arithmetic-and-regularizations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Dumoulin, V., &amp; Visin, F. (2016). A guide to convolution arithmetic for deep learning. arXiv preprint arXiv:1603.07285.</li>
<li>He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition (pp. 770-778).</li>
<li>Ioffe, S., &amp; Szegedy, C. (2015). Batch normalization: Accelerating deep network training by reducing internal covariate shift. arXiv preprint arXiv:1502.03167.</li>
<li>Kamyshanska, H., &amp; Memisevic, R. (2014). The potential energy of an autoencoder. IEEE transactions on pattern analysis and machine intelligence, 37(6), 1261-1273.</li>
<li>Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., &amp; Salakhutdinov, R. (2014). Dropout: a simple way to prevent neural networks from overfitting. The Journal of Machine Learning Research, 15(1), 1929-1958.</li>
<li>Zaremba, W., Sutskever, I., &amp; Vinyals, O. (2014). Recurrent neural network regularization. arXiv preprint arXiv:1409.2329.</li>
</ul>
</div>
<div class="section" id="related-poc">
<span id="related-poc"></span><h3>Related PoC<a class="headerlink" href="#related-poc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/">量子力学、統計力学、熱力学における天才物理学者たちの神学的な形象について</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/historische-semantik-der-entropie-in-der-maxwell-boltzmann-verteilung/">熱力学の前史、マクスウェル＝ボルツマン分布におけるエントロピーの歴史的意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/statistische-mechanik-als-medium-und-ensemble-als-form/">メディアとしての統計力学と形式としてのアンサンブル、そのギブス的類推</a></li>
<li><a class="reference external" href="https://accel-brain.com/das-theologische-bild-genialer-physiker-in-der-quantenmechanik-und-der-statistischen-mechanik-und-thermodynamik/maxwell-damon/">「マクスウェルの悪魔」、力学の基礎法則としての神</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/">Webクローラ型人工知能によるパラドックス探索暴露機能の社会進化論</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/sozialstruktur-des-world-wide-web-und-semantik-der-kunstlichen-intelligenz-des-web-crawlers/">World-Wide Webの社会構造とWebクローラ型人工知能の意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/social-evolution-of-exploration-and-exposure-of-paradox-by-web-crawling-type-artificial-intelligence/semantik-der-semantik-und-beobachtung-der-beobachtung/">意味論の意味論、観察の観察</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/">深層強化学習のベイズ主義的な情報探索に駆動された自然言語処理の意味論</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/tiefe-boltzmann-maschine-als-selbstkodierer/">平均場近似推論の統計力学、自己符号化器としての深層ボルツマンマシン</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/berechnungskostenreduzierung-des-lern-und-designkonzeptes-von-mobilenet/">深層学習の計算コスト削減、MobileNetの設計思想</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/physical-semantics-of-algorithm-design-in-neural-network-optimization-problem/">ニューラルネットワーク最適化問題におけるアルゴリズム設計の物理学的な意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/regularisierungsproblem-und-gan/">正則化問題における敵対的生成ネットワーク(GANs)と敵対的自己符号化器(AAEs)のネットワーク構造</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/hierarchical-latent-variable-model-as-media-and-semi-supervised-learning-of-ladder-network-as-a-form/">階層的潜在変数モデルをメディアとしたラダーネットワークの半教師あり学習形式、ノイズ除去型自己符号化器の機能</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/lyaponov-stability-optimization-in-gan-and-auto-encoder-in-energy-based-models/">エネルギーベースモデルとしての敵対的生成ネットワーク(GAN)と自己符号化器におけるリアプノフ安定</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/naturliche-sprachverarbeitung-des-neuronalen-netzwerkmodells-und-der-netzwerkstruktur-eines-rekursiven-neuronalen-netzwerks/">ニューラルネットワーク言語モデルの自然言語処理と再帰的ニューラルネットワークのネットワーク構造</a></li>
<li><a class="reference external" href="https://accel-brain.com/semantics-of-natural-language-processing-driven-by-bayesian-information-search-by-deep-reinforcement-learning/paradox-of-transfer-learning/">転移学習のパラドックス、脱パラドックス化の形式としての半教師あり学習</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/">ハッカー倫理に準拠した人工知能のアーキテクチャ設計</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/sozialstruktur-des-architekturzentrum-designs-und-architektur-der-semantik/">アーキテクチャ中心設計の社会構造とアーキテクチャの意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/sozialstruktur-der-modernen-gesellschaft-und-semantik-der-hackerethik/">近代社会の社会構造とハッカー倫理の意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/sozialstruktur-des-rational-unified-process-und-semantik-des-architekturentwurfs/">ラショナル統一プロセス(RUP)の社会構造とアーキテクチャ設計の意味論</a></li>
<li><a class="reference external" href="https://accel-brain.com/architectural-design-of-artificial-intelligence-conforming-to-hacker-ethics/objektorientiert-uber-objektorientiert/">オブジェクト指向のオブジェクト指向</a></li>
</ul>
</li>
<li><a class="reference external" href="https://accel-brain.com/data-modeling-von-korrespondenz-in-artificial-paradise/">「人工の理想」を背景とした「万物照応」のデータモデリング</a> (Japanese)<ul>
<li><a class="reference external" href="https://accel-brain.com/data-modeling-von-korrespondenz-in-artificial-paradise/anomalieerkennungsmodell-als-funktionelles-aquivalent-eines-detektivs/">探偵の機能的等価物としての異常検知モデル、謎解きの推論アルゴリズム</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="more-detail-demos">
<span id="more-detail-demos"></span><h3>More detail demos<a class="headerlink" href="#more-detail-demos" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://media.accel-brain.com/_chimera-network-is-web-crawling-ai/">Webクローラ型人工知能：キメラ・ネットワークの仕様</a> (Japanese)<ul>
<li>Implemented by the <code class="docutils literal notranslate"><span class="pre">C++</span></code> version of this library, these 20001 bots are able to execute the dimensions reduction(or pre-learning) for natural language processing to run as 20001 web-crawlers and 20001 web-scrapers.</li>
</ul>
</li>
<li><a class="reference external" href="https://media.accel-brain.com/_chimera-network-is-robo-adviser/">ロボアドバイザー型人工知能：キメラ・ネットワークの仕様</a> (Japanese)<ul>
<li>The 20001 bots can also simulate the portfolio optimization of securities such as stocks and circulation currency such as cryptocurrencies.</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="author">
<span id="author"></span><h2>Author<a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>accel-brain</li>
</ul>
</div>
<div class="section" id="author-uri">
<span id="author-uri"></span><h2>Author URI<a class="headerlink" href="#author-uri" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>https://accel-brain.co.jp/</li>
<li>https://accel-brain.com/</li>
</ul>
</div>
<div class="section" id="license">
<span id="license"></span><h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>GNU General Public License v2.0</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to pydbm’s documentation!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pydbm.html"
                        title="next chapter">pydbm package</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pydbm.html" title="pydbm package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to pydbm’s documentation!"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pydbm  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018-2019, chimera0(RUM).
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>